---
layout: hidden_page
---

* auto-gen TOC:
{:toc}
# Thinking in Java 笔记: 第八章

>   如果java是一本书，那么《think in java》就是这本书的序与目录。



## 多态的一个小坑

此问题仅在子类的变量名与父类相同时出现

```java
public class FieldAccess {

	private static class Super{
		public int value = 1;

		public int getValue() {
			return value;
		}
	}

	private static class Sub extends Super{
		public int value = 0;

		public int getSubValue() {
			return value;
		}
	}

	public static void main(String[] args) {
		Super s = new Sub();
		System.out.printf("%d, %d, %d", s.value, s.getValue(), ((Sub)s).getSubValue());
        // 1, 1, 0
	}

}
```



## 构造器内部的多态方法

当父类构造器使用了非`static/final`方法，且子类中重写了该方法时发生。

见下面的例子

```java
public class PolyConstructors {

	private static class Super{

		protected int value = 0;

		void doSomething() {
			value = 1;
		}

		public Super() {
			doSomething();
		}

	}
	
	private static class Sub extends Super{

		@Override
		void doSomething() {
			value = 2;
		}
	}

	public static void main(String[] args) {
		Super s = new Sub();
		System.out.println(s.value); // 2
	}

}
```

输出为2，说明父类调用了重写后的`doSomething`方法



## 初始化顺序

观察下列代码

```java
package chapter9;

public class Page171Exercise3 {

	private static abstract class Super{
		
		Super(){
			print();
		}
		
		abstract void print();
		
	}
	
	private static class Sub extends Super{

		int value = 11;
		
		@Override
		void print() {
			System.out.println(value);
		}
		
	}
	
	public static void main(String[] args) {
		Super s = new Sub();
        // output: 0
	}

}
```

输出为零是因为复杂对象调用构造器遵循以下顺序：

1.  调用基类（父类）构造器（递归）
2.  按照**声明顺序**调用**成员**的初始化方法
3.  调用导出类的构造器主体

当`Super`类调用`print`时，`value`尚未初始化！（将`value`的类型改为`String`，可以看到输出为`null`）