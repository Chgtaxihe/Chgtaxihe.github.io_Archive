---
layout: hidden_page
---

* auto-gen TOC:
{:toc}
# Thinking in Java 笔记: 第五章

>   如果java是一本书，那么《think in java》就是这本书的序与目录。



## 方法签名（*method signature*）

>   Two of the components of a method declaration comprise the *method signature*—the method's name and the parameter types.

>   The compiler does not consider return type when differentiating  methods, so you cannot declare two methods with the same signature even  if they have a different return type.

摘自：https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

例如：

```java
public void doSomething(int a, double b, char c){
    // do something
}
```

该方法的签名是

```
doSomething(int, double, char)
```



## Object.finalize()

>   **Deprecated**.

摘自文档：https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html

使用`Autocloseable`或`PhantomReference`替代



### 拓展：Java的4种引用方式

参考：https://blog.csdn.net/lqw_student/article/details/52947125

1.  强引用

    ```java
    Object o = new Object();
    ```

2.  软引用；Object o = new Object();
    SoftReference sr = new SoftReference(o);

3.  弱引用

    ```java
    Object o = new Object();
    WeakReference weakReference = new WeakReference(o);
    ```

4.  虚引用

    `PhantomReference`，需要结合`ReferenceQueue`使用



## 垃圾回收器如何工作

这个问题几乎可以用一本书的篇幅去写，此处只是简单描述一下

参考资料：https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html

图片来源：https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html



### 方案1：标记-清除(Mark-Sweep)

最显而易见的方案

扫描堆中的每一个对象，并给未被引用的对象打上标记。

完成扫描后，将被标记对象删除。



### 方案2：分代收集(Generational Garbage Collection)

当VM中对象不断增加，对象列表不断变大，标记-整理方法效率低下的问题就越发明显，此时就需要一种新的方法。

统计数据告诉我们，Java中大多数对象的生命周期很短，由此可以对内存区域进行划分，分别采用不同的策略以优化性能。

如下如所示

<img src="./assest/chapter5.1.png" style="zoom:75%;" />`

-   `Young Generation`：存放新分配的对象
-   `Old Generation`：存放存活时间较长的对象
-   `Permanent Generation`：存放JVM所需的类/方法信息，以及部分Java SE库的类/方法(???)。Java 8取消

------

垃圾回收的步骤如下：

堆起始时为空

1.  新的对象总是被放进`eden`区
2.  当`eden`区满了，进行`minor garbage collection`
    1.  第一次执行`minor GC`时，`eden`区中被引用的对象移动到`S0`，随后清空`eden`
    2.  下一次执行时，`eden`中被引用的对象移动到`s1`，同时，`s0`中被引用的对象亦移动到`s1`，并且“年龄”加一。随后清空`eden`与`s0`
    3.  下一次执行时，重复上述步骤（只不过不再移动到`s1`，而是`s0`）
    4.  `minor GC`执行完后，将年龄达到一定阈值的对象（比如8）移动到`old generation`
3.  当`Old generation`满，执行垃圾回收，称为"Major GC"



### 几种垃圾回收器

1.  The Serial GC

    Java SE 5/6的默认垃圾回收器，采用`mark-compact`的回收方法。

    在回收时需要暂停整个应用程序。

2.  The Parallel GC

    Serial GC的多线程版本

3.  The Concurrent Mark Sweep (CMS) Collector

4.  The G1 Garbage Collector

    Java 7新的回收器，用来取代CMS



## 变量在任何方法(包括构造器)执行前初始化

```java
public class VariableInitialization {

	private static class People{
		int age = getAge();

		private int getAge() {
			return age + 11;
		}
	}

	public static void main(String[] args) {
		People p = new People();
		System.out.println(p.age); // 11
    }
}
```



## enum 类

```java
public class EnumTest {

	private enum Week{
		MON("周一"), TUE("周二"), WED("周三"), 
		THT("周四"), FRI("周五"), SAT("周六"), SUN("周日");

		private String name;
		private Week(String name) {
			this.name = name;
		}

		@Override
		public String toString() {
			return name;
		}
	}

	public static void main(String[] args) {
		for(Week w: Week.values()) {
			System.out.println(w.name() + w.ordinal() + ": " + w);
		}
	}
}
```



