---
layout: hidden_page
---

* auto-gen TOC:
{:toc}
# Thinking in Java 笔记: 第十章

>   如果java是一本书，那么《think in java》就是这本书的序与目录。



## 内部类使用外部变量

```java
public class InnerClass {
	
	private abstract class Work{
		abstract void work();
	}
	
	String mStr = "123";
	
	Work mWork = new Work() {
		void work() {
			mStr = "abc";
		}
	};

	private void test() {
		final String val = "final field";
		Work w = new Work() {
			@Override
			void work() {
				System.out.println(val);
				mStr = "456";
			}
		};
		w.work();
	}
	
	public static void main(String[] args) {
		InnerClass ic = new InnerClass();
		ic.mWork.work();
		System.out.println(ic.mStr); // abc
		ic.test(); // final field
		System.out.println(ic.mStr); // 456
	}
}
```

在JDK 8以前，**写在方法体中**的匿名内部类访问的局部变量必须显式声明为`final`

JDK8以后，`Effectively final`功能会隐式地添加`final`关键字。



当创建一个匿名内部类的时候，Java自动把引用通过自动生成的构造器复制给新建的对象。换句话说，此时内部类的引用如果发生改变，不会影响到外部类，进而导致数据不一致。

为了避免混淆，Java要求局部变量必须通过final修饰。

当想要向外传递信息时，可以用一个size为1的数组来变通。



参考：

-   https://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class
-   https://blog.csdn.net/tianjindong0804/article/details/81710268

