---
layout: hidden_page
title: HDU-6736
---

## [Forest Program](http://acm.hdu.edu.cn/showproblem.php?pid=6736)
$ans = 2^{e_0} * \prod (2^{e_i} - 1)$

其中$e_0$ 为不在环中的边数，$e_i$为各个环中的边数

```c++
#include <bits/stdc++.h>
#define ll long long
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
//cuz i am not using ios
using namespace std;

const int maxn = 3e5 + 1000;
const ll mod = 998244353;

vector<int> G[maxn];
int vis[maxn], dfn[maxn];

int n, m, sum;
ll ans;

ll qpow(ll val, ll t){
    assert(t >= 0);
    ll ret = 1;
    while(t){
        if(t & 1) ret = ret * val % mod;
        val = val * val % mod;
        t >>= 1;
    }
    return ret;
}

void dfs(int u, int fa){
    vis[u] = 1;
    for(int v:G[u]){
        if(v == fa || vis[v] == 2) continue;
        if(vis[v] == 1){ // 也可以通过dfn[u] > dfn[v]来判断
            sum += dfn[u] - dfn[v] + 1;
            ans = ans * ((qpow(2, (dfn[u] - dfn[v] + 1)) - 1 + mod) % mod) % mod;
        }else{
            dfn[v] = dfn[u] + 1;
            dfs(v, u);
        }
    }
    vis[u] = 2;
}

void solve(){
    ans = 1, sum = 0;
    for(int i=0;i<=n;i++) G[i].clear(), vis[i] = 0;

    int u, v;
    for(int i=0; i<m; i++){
        cin >> u >> v;
        G[u].push_back(v), G[v].push_back(u);
    }
    
    for(int i=1;i<=n;i++){
        if(!vis[i]) dfn[i] = 1, dfs(i, 0);
    }

    ans = ans * qpow(2, m - sum) % mod;
    
    cout << ans << '\n';
    
}

signed main(){
    Android;
    while(cin >> n >> m)
        solve();
}

```

