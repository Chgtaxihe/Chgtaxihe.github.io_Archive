---
layout: hidden_page
title: 素性检测与大数分解
---

* auto-gen TOC:
{:toc}


# 素性检测



## 前置1. 费马小定理

$$
a^{p-1}\equiv 1 \mod{p}\quad \text{其中p为质数}
$$

简要证明:

对于数列$\{1,2,3,...,p-1\}$，对每个数字计算$f(x)=xa\mod p$，其中$a$为满足$gcd(a,p)=1$的任意整数，得到新的数列$\{1a,2a,3a,\dots,(p-1)a\}$

新的数列有一下性质

1.  $0<x<p$：显然

2.  数列中的数字两两不相同：

    假设原数列中有两个不同数字$c, d$，使得$f(c)=f(d)$，即有$(ac-ad)\equiv 0 \mod p$

    即$a(c-d)\equiv 0 \mod p$，又因为$(a,p)=1$，因此$(c-d)\mid p$

    因此$c-d=0$，$c=d$，矛盾

根据上述性质，可以知道新的数列经过调整位置后可以得到原数列。

因此$1\times2\times\dots\times(p-1)\equiv 1a\times 2a\times \dots\times (p-1)a \mod p$

即$(p-1)!\equiv a^{p-1} \ (p-1)! \mod p$，又因为$(p-1)!$与$p$互质

因此$a^{p-1}\equiv 1 \mod p$



## 前置2. 二次探测

$$
\text{若p为素数，则} a^2\equiv 1 \mod p\quad\text{的解为}\quad a \equiv 1\mod p
$$

简要证明:
$$
\begin{eqnarray}
a^2-1 && \equiv 0 \mod p \\
(a-1)(a+1) &&\equiv 0 \mod p \\
\end{eqnarray}
$$

由于$p$是素数，显然有$(a-1)(a+1)\ne np, n\in Z^+$，因此
$$
a-1\equiv 0 \mod p \quad \text{或} \quad  a+1\equiv 0 \mod p
$$


## 算法思想

设需要判断的数为$p$:

1.  将$p-1$分解为$2^k*t$的形式
2.  若$p$为素数，则定有$a^{2^k*t}\equiv 1\mod p$（对于任意满足$(a,p)=1$的整数）
3.  因而$a^{2^{k-1}*t}\equiv 1$或$-1$（下面省略符号"$\mod p$"）
4.  若上一步同余于$1$，则$a^{2^{k-2}*t}\equiv1$或$a^{2^{k-2}*t}\equiv -1$
5.  ......

多次随机选取不同的$a$，若任意条件不满足，则数$p$不是质数；否则，$p$极大概率是素数



## 算法实现

```c++
// 求余快速幂
long long qpow(long long base, long long t, long long mod) {
    long long res = 1;
    while (t) {
        if (t & 1) res = res * base % mod;
        t >>= 1;
        base = base * base % mod;
    }
    return res;
}

bool Miller_Rabin(long long p) {
    const int TEST_TIME = 8; // 测试8次

    if (p < 2) return false;
    if ((p & 1) == 0) return p == 2;

    long long t = p - 1;
    int k = 0;
    while ((t & 1) == 0)
        k++, t >>= 1;

    for (int i = 0; i < TEST_TIME; i++) {
        long long a = rand() % (p - 1) + 1; // 通常a可以直接取质数，如:2,5,7,11,...
        long long pow = qpow(a, t, p), last = pow;
        for (int j = 0; j < k; j++) {
            pow = pow * pow % p;
            if (pow == 1 && last != 1 && last != p - 1) return false; // 合数
            last = pow;
        }
        if (pow != 1) return false;
    }
    return true;
}
```



## 正确性

>   The error made by the primality test is measured by the probability for a composite number to be declared probably prime. The more bases *a* are tried, the better the accuracy of the test. It can be shown that if *n* is composite, then at most 1⁄4 of the bases *a* are strong liars for *n*.

能力有限，实在看不懂[这篇文章](https://doi.org/10.1016/0022-314X(80)90084-0)



# 大数分解

