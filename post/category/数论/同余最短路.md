---
layout: hidden_page
title: 同余最短路学习笔记
---

* auto-gen TOC:
{:toc}

# 前言

最短路的奇怪用法




# 例题引入 [洛谷P3403](https://www.luogu.com.cn/problem/P3403)

[AC代码](#洛谷P3403 AC代码)

可以转化成背包大小为$2^{63}$的完全背包问题，保证不会TLE~~

题解：

[参考题解](https://www.luogu.com.cn/blog/L02m/solution-p3403)

设三个操作分别可以上升$a, b, c$层且$a\le b \le c$

设$dist[i]$为满足$k=bx_1 + cx_2$且$k \mod a = i$的最小整数$k$，即仅通过操作$b/c$能够到达的**对$a$取余等于$i$**的最低楼层

对于第$k$层($k \mod a = i$)，若$dist[i] \ne -1$，即$i$可达，则定有$i+ma \ (m\ge0)$可达

因此有$dist[i]=min(dist[(k-b+a)\%a]+b, dist[(k-c+a)\%a]+c)\ (i<a)$ 

那么答案就可以转化为

$ans=\sum_{0\le i \le a}{\lfloor \frac{h-dist[i]}{a} \rfloor + 1}$

也可以看成是一条有向边$edge(i, (i+b)\%a)$边权$w=b$，$c$同理，转化后跑一遍最短路即可



# 更多题目

## [BZOJ 2118]  墨墨的等式



# 附录

## 洛谷P3403 AC代码

```c++
#include <bits/stdc++.h>
#define ll long long
#define pii pair<ll, int> 

using namespace std;

const ll inf = 0x3f3f3f3f3f3f3f3f;
const int maxn = 1e5 + 1000;

ll dist[maxn];

ll h, x, y, z;

void dij(ll s){
    dist[s] = s;
    priority_queue<pii, vector<pii>, greater<pii> >que;
    que.push({dist[s], s});
    while(!que.empty()){
        ll d = que.top().first, u = que.top().second;
        que.pop();
        if(d != dist[u] || d > h) continue; // 不超过h
        if(dist[(u+y)%x] > dist[u]+y){
            dist[(u+y)%x] = dist[u]+y;
            que.push({dist[(u+y)%x], (u+y)%x});
        }
        if(dist[(u+z)%x] > dist[u]+z){
            dist[(u+z)%x] = dist[u]+z;
            que.push({dist[(u+z)%x], (u+z)%x});
        }
    }
}

void solve(){
    cin >> h >> x >> y >> z;
    if(x > y) swap(x, y);
    if(x > z) swap(x, z);
    if(x == 1) {cout << h << endl; return;}
    memset(dist, 0x3f, sizeof dist);
    dij(1);
    ll ans = 0;
    for(int i=0; i<x; i++){
        if(dist[i] > h) continue;
        ans += (h - dist[i])/x + 1;
    }
    cout << ans << endl;
}

int main(){
    solve();
}
```

