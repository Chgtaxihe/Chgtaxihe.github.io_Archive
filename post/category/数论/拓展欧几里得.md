---
layout: hidden_page
title: 拓展欧几里得学习笔记
---

* auto-gen TOC:
{:toc}
# 前言

今天队友在群上问了一题，[链接](https://ac.nowcoder.com/acm/contest/4853/D)，正解是拓展欧几里得，然而我的第一想法是同余最短路（因为我连拓展欧几里得都不会...）~



PS. 同余最短路的复杂度$O(nlogn),\ n=1e5$，拓展欧几里得复杂度$O(1)$



# 拓展欧几里得

求$ax+by=m$的一组解$(x,y)$




## 定理1: $ax+by=m$有整数解，则定有$m\mid gcd(a,b)$

下面用$g$来代替$gcd(a,b)$

可知$a\mid g$且$b\mid g$，因此，有$(ax+by)\mid g$



## 定理2: 若$m\mid gcd(a,b)$，则$ax+by=m$有整数解 (待证)

等我看看书再来补充



这样一来，问题转化为求$ax+by=gcd(a,b)$的一组解$(x,y)$

代码只有四行

```c++
ll exgcd(ll a, ll b, ll & x, ll & y){
	if(!b) return x=1, y=0, a;
    ll g = exgcd(b, a%b, y, x);
    y -= a/b*x;
    return g;
}
```

```python
def exgcd(a: int, b: int):
    if b == 0: return 1, 0, a
    y, x, g = exgcd(b, a % b)
    y -= a//b*x
    return x, y, g
```

下面来证明一下。

------

$ax_0+by_0=gcd(a,b)=gcd(b,a\%b)$

根据定理2，我们有$gcd(b, a\%b)=bx_1+(a\%b)y_1$

因而$ax_0+by_0=bx_1+(a\%b)y_1$

考虑展开求余符号'$\%$'，得到$ax_0+by_0=bx_1+(a -\lfloor a/b \rfloor b)y_1$

稍微化简一下：$ax_0+by_0=ay_1+b(x_1-\lfloor a/b \rfloor y_1)$

显然$x_0,y_0$的一组解为$x_0=y_1,y_0=x_1-\lfloor a/b \rfloor y_1$

------

设$a'=b,b'=a\%b$，显然有$max(a,b)\ge max(a', b')$，因而经过上述步骤之后，问题转化为了一个规模"更小"的子问题，可以递归求解。

考虑递归求解的边界，回想一下欧几里得算法的边界，定有$b=0$，即$ax_n+0y_n=g$，此时的$g=a$。因而$x_n=1,y_n=0$为一组可行解。我们把这组解回代，求出$(x_{n-1},y_{n-1}), (x_{n-2},y_{n-2})...$，最终求得$(x_0,y_0)$



现在得到$ax+by=gcd(a,b)$，要求$ax'+by'=m,\ m\mid gcd(a,b)$，显然有$x'=x*\frac{m}{gcd(a,b)},\ y'=y*\frac{m}{gcd(a,b)}$



## 常用式子

已知$ax+by=m$一组解$(x,y)$，其通解$(x',y')$为

 $$ f(x)=\left\{ \begin{aligned} x' =  x+bt \\ y' =  y+at \end{aligned} \right. (t \in Z)$$ 



没了，就这么简单



