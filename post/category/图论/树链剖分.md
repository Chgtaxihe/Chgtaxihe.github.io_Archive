---
layout: hidden_page
title: 树链剖分学习笔记
---

* auto-gen TOC:
{:toc}


# 树链剖分

只是为了存一下树剖的代码，并标记一下需要注意的地方。



## 例题 洛谷P2486/BZOJ 2243

```c++
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 1000;

int init_tree[maxn];

struct{
    int color_l[maxn * 4], color_r[maxn * 4], color_cnt[maxn * 4], lazy[maxn * 4];
    # define mid ((l+r)>>1)

    void up(int rt){
        color_cnt[rt] = color_cnt[rt<<1] + color_cnt[rt<<1|1];
        color_l[rt] = color_l[rt<<1], color_r[rt] = color_r[rt<<1|1];
        if(color_r[rt<<1] == color_l[rt<<1|1]) color_cnt[rt] --;
    }

    void down(int rt){
        if(lazy[rt] == 0) return;
        color_cnt[rt<<1] = color_cnt[rt<<1|1] = 1;
        color_l[rt<<1] = color_l[rt<<1|1] = color_r[rt<<1] = color_r[rt<<1|1] = lazy[rt];
        lazy[rt<<1] = lazy[rt<<1|1] = lazy[rt];
        lazy[rt] = 0;
    }

    void build(int l, int r, int rt){
        lazy[rt] = 0;
        if(l == r){
            color_l[rt] = color_r[rt] = init_tree[l];
            color_cnt[rt] = 1;
        }else{
            build(l, mid, rt<<1), build(mid+1, r, rt<<1|1);
            up(rt);
        }
    }

    void dye(int l, int r, int dl, int dr, int color, int rt){
        if(dl <= l && r <= dr){
            color_cnt[rt] = 1;
            color_l[rt] = color_r[rt] = color;
            lazy[rt] = color;
        }else{
            down(rt);
            if(dl <= mid) dye(l, mid, dl, dr, color, rt<<1);
            if(dr > mid) dye(mid+1, r, dl, dr, color, rt<<1|1);
            up(rt);
        }
    }

    int query(int l, int r, int ql, int qr, int rt){
        if(ql <= l && r <= qr) return color_cnt[rt];
        down(rt);
        if(qr <= mid) return query(l, mid, ql, qr, rt<<1);
        if(ql > mid) return query(mid+1, r, ql, qr, rt<<1|1);
        int cnt = query(l, mid, ql, qr, rt<<1) + query(mid+1, r, ql, qr, rt<<1|1);
        if(color_r[rt<<1] == color_l[rt<<1|1]) cnt--;
        return cnt;
    }

    int get_color(int l, int r, int pos, int rt){
        if(pos == 0) return -2;
        if(l == r) return color_l[rt];
        down(rt);
        if(pos <= mid) return get_color(l, mid, pos, rt<<1);
        return get_color(mid+1, r, pos, rt<<1|1);
    }

    #undef mid
}tree; // 线段树容易出小毛病！

vector<int> G[maxn];

int init_color[maxn];
int n, m;

struct{
    int sz[maxn], son[maxn], up[maxn], fa[maxn], depth[maxn];
    int dfn[maxn], df;

    void init(int rt, int from){
        fa[rt] = from;
        depth[rt] = depth[from] + 1;
        sz[rt] = 1;
        for(int i=0, v; i<G[rt].size(); i++){
            v = G[rt][i];
            if(v == from) continue;
            init(v, rt);
            sz[rt] += sz[v];
            if(sz[son[rt]] < sz[v]) son[rt] = v;
        }
    }

    void mark(int rt, int from){ // 注意一下这个打标记的方法
        up[rt] = from;
        dfn[rt] = ++df;
        init_tree[df] = init_color[rt];
        if(son[rt]) mark(son[rt], from); // 这里传入的是from而非rt
        for(int i=0, v; i<G[rt].size(); i++){
            v = G[rt][i];
            if(!dfn[v]) mark(v, v); // 直接判dfn是否为0
        }
    }

    int query(int u, int v){
        int ans = 0; 
        while(up[u] != up[v]){
            if(depth[up[u]] > depth[up[v]]) swap(u, v);
            ans += tree.query(1, n, dfn[up[v]], dfn[v], 1);
            // 当然也可以手动保存一下上次链首的颜色，然后比较
            if(tree.get_color(1, n, dfn[up[v]], 1) == tree.get_color(1, n, dfn[fa[up[v]]], 1)) ans--;
            v = fa[up[v]];
        }
        if(depth[u] > depth[v]) swap(u, v);
        ans += tree.query(1, n, dfn[u], dfn[v], 1);
        return ans;
    }    

    void dye(int u, int v, int color){ // 树剖专用格式，找LCA也是这样
        while(up[u] != up[v]){
            if(depth[up[u]] > depth[up[v]]) swap(u, v);
            tree.dye(1, n, dfn[up[v]], dfn[v], color, 1);
            v = fa[up[v]];
        }
        if(depth[u] > depth[v]) swap(u, v);
        tree.dye(1, n, dfn[u], dfn[v], color, 1);
    }

}hld;

signed main(){
    cin >> n >> m;
    for(int i=1; i<=n; i++) cin >> init_color[i];
    for(int i=1, u, v; i<n; i++){
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    hld.init(1, 0);
    hld.mark(1, 0);
    tree.build(1, n, 1);

    char op[50];
    for(int i=0, a, b, c; i<m; i++){
        cin >> op >> a >> b;
        if(op[0] == 'C'){
            cin >> c;
            hld.dye(a, b, c);
        }
        if(op[0] == 'Q'){
            cout << hld.query(a, b) << '\n';
        }
    }
}
```

