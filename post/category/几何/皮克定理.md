---
layout: hidden_page
title: 皮克定理
---

* auto-gen TOC:
{:toc}
# 皮克定理

对于顶点坐标均为整点的简单多边形，其面积$S$、内部格点数$n$、多边形边界上的格点数$s$满足如下关系:

$ S=n+\frac{s}{2}-1$ 



## 例题 POJ 2954

已知三角形三个点坐标，求三角形内部整数点的个数

根据公式，只要求出三角形面积（可以通过叉乘得出）和三条边上整点个数$s$，即可得到内部整点个数

对于两点之间整数点的个数（不含两个端点），有如下公式：

设$dx=abs(x_1-x_0),dy=abs(y_1-y_0)$

若$dx=0$，则$s=dy-1$

若$dx\ne 0$，则$s=sizeof(\{val\mid 0\lt val\le dx, (val\mid\frac{dx}{gcd(dx,dy)})\})-1=gcd(dx,dy) - 1$

两种情况合并一下，得到答案$s=gcd(dx,dy)-1$

```c++
#include <iostream>
#include <algorithm>

using namespace std;

struct point{
    int x, y;
}points[3];

struct vec{
    int x, y;
    vec(point & from, point & to){x = to.x-from.x, y = to.y-from.y;}
    int operator *(const vec & p)const{return x*p.y - y*p.x;}
};

void solve(){
    int area = abs(vec(points[0], points[1]) * vec(points[0], points[2])) / 2;
    vec line[] = {vec(points[0], points[1]), vec(points[0], points[2]), vec(points[1], points[2])};
    int point_on_edge = 3;
    for(int i=0; i<3; i++){
        line[i].x = abs(line[i].x);
        line[i].y = abs(line[i].y);
        int gcd = __gcd(line[i].x, line[i].y);
        point_on_edge += gcd - 1;
    }
    int n = area + 1 - point_on_edge / 2;
    cout << n << '\n';
}

signed main(){
    while(cin >> points[0].x >> points[0].y >> points[1].x >> points[1].y >> points[2].x >> points[2].y){
        bool flag = true;
        for(int i=0; i<3; i++) if(points[i].x != 0 || points[i].y != 0) flag = false;
        if(flag) break;
        solve();
    }
}
```



## 例题 Codeforces 559D

