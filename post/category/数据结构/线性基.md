---
layout: hidden_page
title: 线性基学习笔记
---

* auto-gen TOC:
{:toc}
# 前言

类欧几里得只是复杂度同欧几里得相似，跟欧几里得没有关系。



# 二进制异或下的线性基

待补充



# 实数下的线性基

## 例题 [洛谷P3265](https://www.luogu.com.cn/problem/P3265)

注意精度问题，要么用`long double`(GCC有效，VC无效，其他编译器不清楚)，要么将`eps`调大并祈求数据不要太刁钻

见代码

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxm = 500 + 10;

struct vec{
    long double val[maxm];
};

const long double eps = 1e-7;
struct linear_base{
    vec base[maxm];
    bool has_val[maxm];
    int m;
    bool is_zero(long double v){return fabs(v) < eps;}

    void init(int bits){
        m = bits;
        for(int i=0; i<=bits; i++) has_val[i] = false;
    }

    bool insert(vec vect){
        for(int i=0; i<m; i++){
            if(!is_zero(vect.val[i])){
                if(!has_val[i]){
                    has_val[i] = true;
                    base[i] = vect;
                    return true;
                }
                long double k = vect.val[i] / base[i].val[i];
                for(int j=i; j<m; j++) vect.val[j] -= k * base[i].val[j];
            }
        }
        return false;
    }
}lb;

struct item{
    vec vect;
    ll cost;
    bool operator <(const item & other)const{
        return cost < other.cost;
    }
}items[maxm];

void solve(){
    int n, m;
    cin >> n >> m;
    lb.init(m);
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++) cin >> items[i].vect.val[j];
    }
    for(int i=0; i<n; i++) cin >> items[i].cost;
    sort(items, items + n);
    
    ll cost = 0, cnt = 0;
    for(int i=0; i<n; i++){
        if(lb.insert(items[i].vect)){
            cost += items[i].cost, cnt++;
        }
    }
    cout << cnt << " " << cost << endl;
}

int main(){
    solve();
}
```



