---
layout: hidden_page
title: 树状数组学习笔记
---

* auto-gen TOC:
{:toc}


# 树状数组求前缀和

```c++
int val[maxn];
void modify(int pos, int delta){
    for(int i=pos; i<=max_pos; i+=(-i)&i) val[i] += delta;
}
int query(int pos){
    int ret = 0;
    for(int i=pos; pos>0; i-=(-i)&i) ret += val[i];
    return ret;
}
```



# 树状数组求区间最值

## 例题[洛谷P3865](https://www.luogu.com.cn/problem/P3865)

ST表的模板题，肯定不能用ST做啦~

ST表(1.22s，8.51M)，树状数组（1.29s，6.9M），耗时差不多，但内存占用少了

```c++
#include <bits/stdc++.h>
#define Android ios::sync_with_stdio(false), cin.tie(NULL)

using namespace std;

const int maxn = 1e6 + 100;

int bit[maxn] = {0}, val[maxn];

void update(int x, int pos, int n){
    while(pos <= n){
        bit[pos] = max(bit[pos], x);
        pos += (-pos) & pos;
    }
}

int query(int l, int r){ // 结果包含左/右端点
    int ans = val[r], tmp;
    while(l <= r){
        tmp = r - (r & (-r));
        if(tmp >= l){
            ans = max(ans, bit[r]);
            r = tmp;
        }else{
            ans = max(ans, val[r--]); // 当减去lowbit后小于l时，同原数组对比
        }
    }
    return ans;
}

signed main(){
    int n, m;
    cin >> n >> m;
    for(int i=1; i<=n; i++) {
        cin >> val[i];
        update(val[i], i, n);
    }
    for(int i=0, l, r; i<m; i++){
        cin >> l >> r;
        cout << query(l, r) << '\n';
    }
}
```



# 树状数组处理二位偏序

## 例题Codeforces 12D

题意：求出满足$\exist i,\ a_x<a_i \&\ b_x<b_i\&\ c_x<c_i$的$x$的个数

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int inf = 0x3f3f3f3f;
const int maxn = 5e5 + 1000;

struct val {
    int a, b, c, idx;
} vals[maxn], tmp[maxn];

bool cmp1(const val & v1, const val & v2){
    if(v1.a == v2.a) {
        if(v1.b == v2.b) return v1.c < v2.c;
        else return v1.b < v2.b;
    }
    return v1.a < v2.a;
}

int va[maxn]={0};
int greatest;
// 树状数组维护p到greatest中最大的值
int query(int p) {
    int ret = 0;
    for(int i = p; i <= greatest; i += (-i)&i) ret = max(ret, va[i]);
    return ret;
}

void add(int p, int v) {
    for(int i = p; i > 0; i -= (-i)&i) va[i] = max(va[i], v);
}

signed main() {
    int n, ans=0;
    cin >> n;
    vector<int> unq(n + 1);
    for(int i = 1; i <= n; i++) cin >> vals[i].a, vals[i].idx = i;
    for(int i = 1; i <= n; i++) {
        cin >> vals[i].b;
        vals[i].b++;
        unq[i] = vals[i].b;
    }
    for(int i = 1; i <= n; i++) cin >> vals[i].c;
    
    // 对b离散化
    sort(unq.begin(), unq.end());
    unq.resize(unique(unq.begin(), unq.end()) - unq.begin());
    greatest = unq.size() + 3;
    for(int i=1; i<=n; i++) vals[i].b = lower_bound(unq.begin(), unq.end(), vals[i].b) - unq.begin();

    sort(vals + 1, vals + n + 1, cmp1); // 对a排序，问题降为二位偏序问题

    int j = n;
    for(int i=n; i>0; i--){
        if(vals[i].a < vals[j].a){
            for(; j>i; j--) add(vals[j].b, vals[j].c);
        }
        if(query(vals[i].b+1) > vals[i].c) {
            ans++;
        }
    }
    cout << ans << endl;
}
```



