---
layout: hidden_page
title:  训练补题-牛客训练赛6
---

* auto-gen TOC:
{:toc}


# 牛客训练赛6补题记录



## H: Harmony Pairs 数位dp

万恶的数位dp

在dp时，其实我们并不关心$A,B$分别是多少，只关心$S(B)-S(A)$等于多少，该状态占一维。

还要考虑$B\le N$，$A=B$两类限制，因此再多出两维。



AC代码：（delta代表$S(B)-S(A)$的值）

```c++
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define int128 __int128_t
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
#define redirect_input freopen("./input.txt", "r", stdin);
#define redirect_output freopen("./input.txt", "w", stdout);
#define debug(s, r) std::cerr << #s << ": " << (s) << (r==0?' ':'\n')
#define pii pair<int, int>
#define sqr(x) ((x)*(x))
using namespace std;

void timeit(std::function<void()> exec){
    clock_t start = clock();
    exec();
    cout << "time: " << ((double)clock() - start) / CLOCKS_PER_SEC << endl;
}

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int inf = 0x3f3f3f3f;
const int maxn = 2e7 + 10;
const ll mod = 1e9 + 7;

char buffer[120];
int bits;

ll dp[120][2010][2][2];

ll calc(int n, int delta, int limit_n, int AequB){
    if(n > bits) return delta < 1000;

    ll & ans = dp[n][delta][limit_n][AequB];
    if(ans != -1) return ans;
    ans = 0;

    int x = limit_n?(buffer[n]):9;
    for(int i=0; i<=x; i++){ // b[n] = i
        int y = AequB?i:9;
        for(int j=0; j<=y; j++){
            ans = (ans + calc(n + 1, delta + i - j, limit_n && (i == x), AequB && (j == i))) % mod;
        }
    }
    return ans;
}

void solve(){
    memset(dp, -1, sizeof dp);

    cin >> (buffer + 1);
    bits = strlen(buffer + 1);
    for(int i=1; i<=bits; i++) buffer[i] -= '0';

    cout << calc(1, 1000, 1, 1) << '\n';
}

signed main(){
    Android;
    solve();
}
```

