---
layout: hidden_page
title:  训练补题-牛客训练赛6
---

* auto-gen TOC:
{:toc}


# 牛客训练赛6补题记录



## H: Harmony Pairs 数位dp

万恶的数位dp

在dp时，其实我们并不关心$A,B$分别是多少，只关心$S(B)-S(A)$等于多少，该状态占一维。

还要考虑$B\le N$，$A=B$两类限制，因此再多出两维。



AC代码：（delta代表$S(B)-S(A)$的值）

```c++
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define int128 __int128_t
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
#define redirect_input freopen("./input.txt", "r", stdin);
#define redirect_output freopen("./input.txt", "w", stdout);
#define debug(s, r) std::cerr << #s << ": " << (s) << (r==0?' ':'\n')
#define pii pair<int, int>
#define sqr(x) ((x)*(x))
using namespace std;

void timeit(std::function<void()> exec){
    clock_t start = clock();
    exec();
    cout << "time: " << ((double)clock() - start) / CLOCKS_PER_SEC << endl;
}

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int inf = 0x3f3f3f3f;
const int maxn = 2e7 + 10;
const ll mod = 1e9 + 7;

char buffer[120];
int bits;

ll dp[120][2010][2][2];

ll calc(int n, int delta, int limit_n, int AequB){
    if(n > bits) return delta < 1000;

    ll & ans = dp[n][delta][limit_n][AequB];
    if(ans != -1) return ans;
    ans = 0;

    int x = limit_n?(buffer[n]):9;
    for(int i=0; i<=x; i++){ // b[n] = i
        int y = AequB?i:9;
        for(int j=0; j<=y; j++){
            ans = (ans + calc(n + 1, delta + i - j, limit_n && (i == x), AequB && (j == i))) % mod;
        }
    }
    return ans;
}

void solve(){
    memset(dp, -1, sizeof dp);

    cin >> (buffer + 1);
    bits = strlen(buffer + 1);
    for(int i=1; i<=bits; i++) buffer[i] -= '0';

    cout << calc(1, 1000, 1, 1) << '\n';
}

signed main(){
    Android;
    solve();
}
```



## B: Binary Vector

对于$N$维向量组，考虑每次随机向其中加入一个向量（直至向量组的秩$R=N$）。

显然，若当前向量组的大小为$x$，那么加入一个新向量$v$有$2^N$中可能，其中会导致向量组线性相关的有$2^x$种可能。（即：从原向量组中$x$个向量相异或，有$2^x$中选择方法）。

因此，该题的公式为

$$
f_n=\prod_{i=0}^{n-1} \frac{2^n-2^i}{2^n}=\frac{\prod\limits_{i=0}^{n-1}(2^n-2^i)}{2^{n^2}}
$$

“容易”发现

$$
f_n=\frac{2^{n-1}f_{n-1}*(2^n-1)}{2^{2n - 1}}
$$

线性递推即可。

AC代码：

```c++
#include <bits/stdc++.h>
#define ll long long
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
using namespace std;

template<typename F, typename... Args>
void timeit(F func, Args&&... args){
    clock_t start = clock();
    func(std::forward<Args>(args)...);
    # ifndef ONLINE_JUDGE
    cerr << "time: " << ((double)clock() - start) / CLOCKS_PER_SEC << endl;
    # endif
}

const int maxn = 2e7 + 1000;
const ll mod = 1e9 + 7;
const ll inv2 = 500000004;
ll ans[maxn];

ll qpow(ll base, ll t){
    ll ret = 1;
    while(t){
        if(t & 1) ret = ret * base % mod;
        t >>= 1;
        base = base * base % mod;
    }
    return ret;
}

void init(){
    ans[1] = 1 * inv2;
    ll pow2 = 2, dem = inv2;
    for(int i=2; i<maxn; i++){
        pow2 = pow2 * 2 % mod;
        dem = dem * inv2 % mod;
        ans[i] = ans[i-1] % mod * (pow2 - 1 + mod) % mod;
        ans[i] = ans[i] * dem % mod;
    }
    for(int i=2; i<maxn; i++) ans[i] = ans[i - 1] ^ ans[i];
}

void solve(){
    int n; cin >> n;
    cout << ans[n] << '\n';
}

signed main(){
    timeit(init);
    Android;
    int t; cin >> t;
    while(t--)
        solve();
}
```



## G: Grid Coloring

有一种很巧妙的方法



AC代码:

```c++
#include <bits/stdc++.h>
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
using namespace std;

const int maxn = 4e4 + 1000;

int n, k;
int hor[maxn], ver[maxn];

void solve(){
    cin >> n >> k;
    if(n == 1 || 2 * n * (n + 1) % k != 0 || k == 1){
        cout << "-1\n";
        return;
    }
    if(n % k != 0){
        int color = 1;
        for(int r = 0; r < 2 * (n + 1); r++){
            for(int c = 0; c < n; c++){
                cout << color << " ";
                color = color % k + 1;
            }
            cout << '\n';
        }
    }else{
        int color = 0;
        for(int r = 0; r < 2 * (n + 1); r++){
            int init = (r & 1) + 1;
            for(int c = 0; c < n; c++){
                cout << init << " ";
                init = init % k + 1;
            }
        }
        cout << '\n';
    }
}

signed main(){
    Android;
    int t; cin >> t;
    while(t--)
        solve();
}
```





## J: Josephus Transform

对于一个置换操作，可以视作矩阵乘法，如下所示。

$$
\begin{align}
\begin{bmatrix}
  0/1&  0/1& 0/1\\
  0/1&  0/1& 0/1\\
  0/1&  0/1& 0/1\\
\end{bmatrix} 
\begin{bmatrix}
 a\\
 b\\
 c
\end{bmatrix}=
\begin{bmatrix}
 a'\\
 b'\\
 c'
\end{bmatrix}
\end{align}
$$

考虑到矩阵乘法具有结合律，因此**推测**置换操作也具有结合律！因此可以使用快速幂。具体细节或证明见置换群笔记（或许会有？）。





