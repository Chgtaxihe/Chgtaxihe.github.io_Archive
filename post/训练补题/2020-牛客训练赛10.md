---
layout: hidden_page
title:  训练补题-牛客训练赛10
---

* auto-gen TOC:
{:toc}


# 牛客训练赛10补题记录



## C: Decrement on the Tree

将边的问题转化为点的问题：若最少需要$x$条边来完全覆盖，意味着需要$2x$个端点。

可以贪心的做：

-   如果该节点为叶子节点，其与父节点连接的边边权为$w$，显然该节点应该作为端点次数$ans=w$

-   该节点不是叶子节点，若要使得端点数最少：

    令连接到该节点的边权最大值为$maxe$，边权和为$sume$

    -   若$sume - maxe<maxe$，说明最大的边权过大，无法与其他边配对，此时$ans=maxe-(sume-maxe)$
    -   否则，根据奇偶性，$ans = sume\%2$

上述两类情况可以合并

在做的时候，只需要维护各个点的$maxe$与$sume$即可（使用`multiset`）



注意`multiset.erase`的用法！

```c++
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define int128 __int128_t
#define Android ios::sync_with_stdio(false), cin.tie(NULL)
#define redirect_input freopen("./input.txt", "r", stdin);
#define redirect_output freopen("./output.txt", "w", stdout);
#define debug(s, r) std::cerr << #s << ": " << (s) << (r==0?' ':'\n')
#define pii pair<ll, ll>
#define sqr(x) ((x)*(x))
using namespace std;

const int maxn = 1e5 + 100;

ll u[maxn], v[maxn], w[maxn];
ll sum[maxn];
multiset<ll> edges[maxn];

ll calc(int x){
    ll maxe = edges[x].empty()?0:*prev(edges[x].end());
    return max(2 * maxe - sum[x], sum[x] & 1);
}

void solve(){
    int n, q;
    cin >> n >> q;
    for(int i=1; i<n; i++){
        cin >> u[i] >> v[i] >> w[i];
        edges[u[i]].insert(w[i]);
        edges[v[i]].insert(w[i]);
        sum[u[i]] += w[i];
        sum[v[i]] += w[i];
    }

    ll ans = 0;
    for(int i=1; i<=n; i++) ans += calc(i);
    cout << ans / 2 << '\n';

    for(ll i=0, p, dw; i<q; i++){
        cin >> p >> dw;
        ans -= calc(u[p]) + calc(v[p]);
        sum[u[p]] = sum[u[p]] + dw - w[p];
        sum[v[p]] = sum[v[p]] + dw - w[p];
        edges[u[p]].erase(edges[u[p]].find(w[p])), edges[u[p]].insert(dw);
        edges[v[p]].erase(edges[v[p]].find(w[p])), edges[v[p]].insert(dw);
        w[p] = dw;
        ans += calc(u[p]) + calc(v[p]);
        cout << ans / 2 << '\n';
    }
}

signed main(){
    Android;
    solve();
}
```



## J: Identical Trees