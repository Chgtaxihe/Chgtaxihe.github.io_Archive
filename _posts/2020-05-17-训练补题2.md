---
layout: post
title: 训练补题2
---

* auto-gen TOC:
{:toc}


之前的训练补题记录已经有50k那么大了，用Typora编辑会很卡，于是开个新篇



# 组队排位赛11

## Gym 102483C 几何

[我的题解](/post/solutions/Gym102483C.html)



## Gym 102483H 细节

明明巨简单的题，训练的时候做了超久（而且还没做出来），心态锻炼得还不够好。

假设开头为$0$，可以发现如果当前位为$0$，那么一定经历了偶数次变换。

将上述规律拓展，又因为结尾一定是$0$，因而如果$c$为奇数，那么第一位一定是$1$，否则第一位一定是$0$。

```c++
#include <bits/stdc++.h>
using namespace std;
char ans[500010] = {0};
int n, c, b;

int main(){
    cin >> n >> c >> b;
    for(int i=0, z; i<b; i++){
        cin >> z;
        ans[z] = '0';
    }
    ans[1] = (c&1)?'1':'0';
    for(int i=2; i<=n; i++){
        if(ans[i] == 0){
            ans[i] = c?(ans[i-1] ^ 1):ans[i-1];
        }
        if(ans[i] != ans[i-1]) c--;
    }
    cout << ans + 1 << endl;
}
```



## Gym 102483G 细节

其实不难，就是debug比较烦。静下来想一想就能1A，但是一急躁肯定就过不了。

题解给了三种做法，下面代码属于第二种

关键点在于：

1.  如果玩家转弯了，那么就让他再也无法碰到之前的砖块。这样一来我们就不用去查询当前方向是否有砖块阻隔，进而免去了用二位数组储存地图的麻烦。（当然，也可以判断一下接下来是否为"LRLR"重复的情况，如果是的话直接跳过）
2.  输出"impossible"只有两种情况
    1.  以"LRL"、"RLR"、"UDU"、"DUD"结尾
    2.  两个相邻的指令重复，如"LL"、"RR"。

```c++
#include <bits/stdc++.h>
#define pii pair<int, int>

using namespace std;

const int maxn = 60, inf = 0x3f3f3f3f;
char buffer[maxn], pattern[][4] = {"LRL", "RLR", "UDU", "DUD"};;
int len;
int delta_x[] = {-1, 1, 0, 0};
int delta_y[] = {0, 0, 1, -1};
map<char, int> id = {{'L', 0}, {'R', 1}, {'U', 2}, {'D', 3}};

signed main(){
    cin >> buffer;
    len = strlen(buffer);
    bool fail = false;
    for(int i=1; i<len; i++) if(buffer[i] == buffer[i-1]) fail = true;
    if(len >= 3){
        for(int i=0; i<4; i++){
            bool check = true;
            for(int j=len-3, p=0; j<len; j++) if(buffer[j] != pattern[i][p++]) check = false;
            if(check) fail = true;
        }
    }
    if(fail){ // 排除掉不能的情况
        cout << "impossible\n";
        return 0;
    }
    pii prev_pos = {inf, inf}, cur_pos = {0, 0};
    vector<pii> blocks;
    int step_abs = 1;
    for(int i=0; i<len; i++){
        if(i >= 2 && (id[buffer[i-1]]^1) == id[buffer[i]] && id[buffer[i-2]] == id[buffer[i]]){ // 判断"LRLR"这一类情况
            swap(cur_pos, prev_pos);
        }else{
            int op = id[buffer[i]];
            int nx = cur_pos.first + step_abs * delta_x[op];
            int ny = cur_pos.second + step_abs * delta_y[op];
            swap(cur_pos, prev_pos);
            cur_pos = {nx, ny};
            blocks.push_back({nx + delta_x[op], ny + delta_y[op]});
            step_abs *= 2; // 这里直接*2，由于n<=20，因此不会超过1e9
        }
    }
    int dx = cur_pos.first, dy = cur_pos.second;
    cout << -dx << " " << -dy << '\n' << blocks.size() << '\n';
    for(pii block: blocks){
        cout << block.first - dx << " " << block.second - dy << "\n";
    }
}
```

------

介绍一下另外两种做法

1.  每个格子有$5\%$的几率为墙，然后跑一边，如果能跑通并且到达一个**从未访问过的点**则输出，否则就重新随机

2.  设定一个大小为$x=2$的方格，并在方格两端都添加方块。每次转向时，$x$增大并在两端添加方块

    例如：现在$x=2$，玩家在$(1,0)$，上一个命令是$L/R$而当前命令是$U/D$，那么$x$增大变为$3$，并且在$(1,3),(1,-3)$放置方格。



## Gym 102483J *

## Gym 102483E *

## Gym 102483A *

## Gym 102483D *

## Gym 102483F *



