---
layout: post
title: 训练补题2
---

* auto-gen TOC:
{:toc}


之前的训练补题记录已经有50k那么大了，用Typora编辑会很卡，于是开个新篇



# 组队排位赛11

## Gym 102483C 几何

[我的题解](/post/solutions/Gym102483C.html)



## Gym 102483H 细节

明明巨简单的题，训练的时候做了超久（而且还没做出来），心态锻炼得还不够好。

假设开头为$0$，可以发现如果当前位为$0$，那么一定经历了偶数次变换。

将上述规律拓展，又因为结尾一定是$0$，因而如果$c$为奇数，那么第一位一定是$1$，否则第一位一定是$0$。

```c++
#include <bits/stdc++.h>
using namespace std;
char ans[500010] = {0};
int n, c, b;

int main(){
    cin >> n >> c >> b;
    for(int i=0, z; i<b; i++){
        cin >> z;
        ans[z] = '0';
    }
    ans[1] = (c&1)?'1':'0';
    for(int i=2; i<=n; i++){
        if(ans[i] == 0){
            ans[i] = c?(ans[i-1] ^ 1):ans[i-1];
        }
        if(ans[i] != ans[i-1]) c--;
    }
    cout << ans + 1 << endl;
}
```



## Gym 102483G 细节

其实不难，就是debug比较烦。静下来想一想就能1A，但是一急躁肯定就过不了。

题解给了三种做法，下面代码属于第二种

关键点在于：

1.  如果玩家转弯了，那么就让他再也无法碰到之前的砖块。这样一来我们就不用去查询当前方向是否有砖块阻隔，进而免去了用二位数组储存地图的麻烦。（当然，也可以判断一下接下来是否为"LRLR"重复的情况，如果是的话直接跳过）
2.  输出"impossible"只有两种情况
    1.  以"LRL"、"RLR"、"UDU"、"DUD"结尾
    2.  两个相邻的指令重复，如"LL"、"RR"。

```c++
#include <bits/stdc++.h>
#define pii pair<int, int>

using namespace std;

const int maxn = 60, inf = 0x3f3f3f3f;
char buffer[maxn], pattern[][4] = {"LRL", "RLR", "UDU", "DUD"};;
int len;
int delta_x[] = {-1, 1, 0, 0};
int delta_y[] = {0, 0, 1, -1};
map<char, int> id = { {'L', 0}, {'R', 1}, {'U', 2}, {'D', 3} };

signed main(){
    cin >> buffer;
    len = strlen(buffer);
    bool fail = false;
    for(int i=1; i<len; i++) if(buffer[i] == buffer[i-1]) fail = true;
    if(len >= 3){
        for(int i=0; i<4; i++){
            bool check = true;
            for(int j=len-3, p=0; j<len; j++) if(buffer[j] != pattern[i][p++]) check = false;
            if(check) fail = true;
        }
    }
    if(fail){ // 排除掉不能的情况
        cout << "impossible\n";
        return 0;
    }
    pii prev_pos = {inf, inf}, cur_pos = {0, 0};
    vector<pii> blocks;
    int step_abs = 1;
    for(int i=0; i<len; i++){
        if(i >= 2 && (id[buffer[i-1]]^1) == id[buffer[i]] && id[buffer[i-2]] == id[buffer[i]]){ // 判断"LRLR"这一类情况
            swap(cur_pos, prev_pos);
        }else{
            int op = id[buffer[i]];
            int nx = cur_pos.first + step_abs * delta_x[op];
            int ny = cur_pos.second + step_abs * delta_y[op];
            swap(cur_pos, prev_pos);
            cur_pos = {nx, ny};
            blocks.push_back({nx + delta_x[op], ny + delta_y[op]});
            step_abs *= 2; // 这里直接*2，由于n<=20，因此不会超过1e9
        }
    }
    int dx = cur_pos.first, dy = cur_pos.second;
    cout << -dx << " " << -dy << '\n' << blocks.size() << '\n';
    for(pii block: blocks){
        cout << block.first - dx << " " << block.second - dy << "\n";
    }
}
```

------

介绍一下另外两种做法

1.  每个格子有$5\%$的几率为墙，然后跑一边，如果能跑通并且到达一个**从未访问过的点**则输出，否则就重新随机

2.  设定一个大小为$x=2$的方格，并在方格两端都添加方块。每次转向时，$x$增大并在两端添加方块

    例如：现在$x=2$，玩家在$(1,0)$，上一个命令是$L/R$而当前命令是$U/D$，那么$x$增大变为$3$，并且在$(1,3),(1,-3)$放置方格。



## Gym 102483J *

## Gym 102483E *

## Gym 102483A *

## Gym 102483D *

## Gym 102483F *



# 组队排位赛12

## Gym 102396C 暴力 复杂度分析

解法：并查集维护连通性，`vector<int> frient`存朋友关系，当两个连通块合并时，遍历节点数较少的连通块的节点`v`，遍历`u:frient[v]`，判断答案是否+1即可

时间复杂度$O(k+(q+m)log_2q)$？？

```c++
struct union_set{
    const static int max_node = 1e5 + 1000;
    int head[max_node];
    
    int find(int x){return head[x]==x?x:head[x]=find(head[x]);}
    void init(int node_cnt){for(int i=node_cnt; i>=0; i--) head[i] = i;}
    bool merge(int u, int v){
        u = find(u), v = find(v);
        if(u == v) return false;
        if(un[u].size() > un[v].size()) swap(u, v);
        for(int nd:un[u]){
            for(int f:frient[nd]){
                if(v == find(f)) ans[nd]++, ans[f]++;
            }
        }
        for(int nd:un[u]) un[v].push_back(nd);
        un[u].clear();
        head[u] = v;
        return true;
    }
}unset;
```



## Gym 102396K LCT*

## Gym 102396J 数学*



# 组队排位赛13: 2020 Petrozavodsk Winter Camp, Jagiellonian U Contest

##  Gym 102576A 数学 思维*

题意：给定排列$n$，即${1,2,3,\cdots,n}$。

将数字两两匹配包装（每份包装的价格为1），使得每个配对的最大公因子大于1，未配对的数字单独包装。

求小的花费。

题解：

设配对数为$k$，那么答案为$(n-2k)+k=n-k$

对于素数$v>\lceil\frac{n}{2}\rceil$，只能单独包装（无法配对），因而设$D(n)=大于\lceil\frac{n}{2}\rceil的素数个数$，有上界$k\le\lfloor\frac{n-D(n)}{2}\rfloor$

把数字按其最大质因子分类，假设某一类对应的质因子为$p$，若其大小为偶数，则可以完全匹配，否则，我们让$2p$不参与类内的匹配，并尝试与其他类中剩余的元素进行匹配。

以上方法得到的$k$等于$\lfloor\frac{n-D(n)}{2}\rfloor$

问题转变为：如何求区间$[l,2l]$内的质数个数，这部分内容见我的笔记[素数计数问题](/post/category/数论/素数计数问题.html)



## Gym 102576B *

## Gym 102576C *

## Gym 102576D *

## Gym 102576E *

## Gym 102576F *

## Gym 102576G *

## Gym 102576H *

## Gym 102576I *

## Gym 102576J *

## Gym 102576K *