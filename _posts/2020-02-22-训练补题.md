---
layout: post
title: 训练补题
---

<style> 
img {
    margin-left: auto; 
    margin-right:auto; 
    display:block;
}
</style>

* auto-gen TOC:
{:toc}
# 个人排位赛1

## UVA-1395 生成树

问题：给定一个无向图，求最大边权与最小边权差值最小的生成树

解：假定该生成树里权值最小的边为$m$，此时最优解中最大的边对应着以$m$为最小边的最小生成树$tree_{min}$的最大边（假设存在另一合法生成树$tree_p$使得$max\_edge(tree_p) < max\_edge(tree_{min})$，由`Kruskal`算法的证明可知，$tree_p$中有环，且存在多于1个联通分量，故不合法）

#### Kruskal证明

假设存在某一步，算法选择了边$E_1$但是应选择$E_2$才能得到最小生成树$tree_{min}$，那么我们在$tree_{min}$中加入边$E_1$，此时该图中存在一个环，且环中存在长度大于$E_1$的边，此时将该边替换为$E_1$则可得到更优的生成树。



## HYSBZ-2257 [裴蜀定理](https://blog.csdn.net/lleozhang/article/details/82935400)

该类倒水问题可以简化为$ax + by + cz + ... = C$

问题：给定$n$个瓶子，从中选出$k$个，使得用这$k$个瓶子倒出的水的最小值最大

答：由裴蜀定理知$ax + by + cz + ...=C$有解当且仅当$gcd(a, b, c, ...)|C$

问题转化为从$n$个数中选出$k$个使得$gcd(v_1, v_2, ..., v_k)$最大

那么我们求出所有数字的所有因子，并从大往小遍历，若因子个数多于$k$，即为答案



## Codeforces 757C 算法实现

题目不难，问题在于如何分组

由于$\sum{g_i}<5*10^5$，因此，我们可以使用`vector<int> p[maxm]`，对于在`i`馆的宝可梦`j`，我们向`p[j]`中`push_back`一下`i`

那么如果`i`可以转化为`j`，既有`p[i] == p[j]`（直接比较`vector`）

`sort`一下再比较就好



## HDU6346 [KM算法(二分图最佳完美匹配)](https://www.cnblogs.com/zpfbuaa/p/7218607.html) [链接2](https://www.cnblogs.com/wenruo/p/5264235.html) [链接3](https://blog.sengxian.com/algorithms/km)

题意：求权值和最小的完全匹配

把cost取一下反即可

注意，这题不能使用dfs版本的km！！

### 关联

[匈牙利算法](https://www.renfei.org/blog/bipartite-matching.html)

[Ford-Fulkerson](https://zh.wikipedia.org/wiki/Ford%E2%80%93Fulkerson%E7%AE%97%E6%B3%95)



## BZOJ1006 [弦图](https://www.cnblogs.com/lcf-2000/p/6259846.html) [链接2](https://oi-wiki.org/graph/chord/)

题意：给定一张弦图，要求相邻的点颜色不同，请你根据[ppt](http://files.cnblogs.com/files/lcf-2000/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE-cdq.pdf)第69页求出最小染色数

题解：根据ppt，弦图的最小染色数=最大团的点数

问题转变成了求最大团的点个数

注意：

1.  PPT中的"诱导子图"即"导出子图"(induced subgraph)
2.  图的极大团/最大团为NP-C问题，弦图的极大团可以在多项式复杂度的时间内完成
3.  ？？？



## BZOJ1499 三维DP

题意：累了，自己看吧

题解：

设$dp[i][x][y]$为第$i$个时间段后，以$(x,y)$为结束位置时，走过的最长路程

假设第$i$个时间段向右倾斜，那么

$dp[i][x][y] = max(dp[i-1][x][s] + y - s)$ for s in range(max(y-时间长度, left_most_block), y+1)

那么，对于固定的$i, x$，可以用单调队列来维护$dp[i-1][x][s]$（边dp边计算上一时间段的单调队列信息）

代码较长，需要小心低级错误



小技巧: memset(v, 128, sizeof v) 可用来填充`-inf`



# 个人排位赛2



## BZOJ5028 线段树上GCD

题解： $gcd(a, b, c, ...)=gcd(a, b-a, c-b, ...)$

因此可以用线段树维护差分数组、区间gcd

当对$(l, r)$加上$x$，相当于$v_l+=x,v_{r+1}-=x$

对$(l, r)$统计答案，即求$gcd(\sum_i^l{v_i}, gcd(v_{l+1}, ..., v_r))$

注意：注意在线段树中特判$ql>qr$的情况（当查询$l=r$时可能出现）



## Gym101237A 线段树/主席树

题解：

### 巧用线段树

用线段树维护出现/未出现的值，线段树上每一个点代表其出现的时间，未出现的赋值为-inf，维护时间的最小值。

考虑对查询的区间进行排序，使得区间的右端点依次增大。从1到n依次遍历数组$A$，并向线段树中插入该数字。对于区间查询$(l, r)$，只需寻找线段树上出现时间小于$l$的位置即可。

### 主席树

事实上，主席树的做法同线段树差不多，只是不需要对查询区间排序而已（支持在线查询！！）。



## [计蒜客41413](https://vjudge.net/problem/计蒜客-41413) 生成函数

对不起，不会



### 关联

[整数划分](https://blog.csdn.net/u011889952/article/details/44813593)

广义牛顿二项式

泰勒展开



## HDU6661 后缀数组

题解:

先去做POJ3693，然后注意以下几点

1. HDU给了6秒的时限。向左/右拓展请大胆的用两个SA(减少分类讨论的难度)
2. 对k为1的情况进行特判(要保证循环节出现)

2.  求向左拓展的长度时别忘了字符串时翻转过来的，对应的位置应该从$pos$变为$len-pos-1$
3.  为了避免右端重复统计，遍历$1 ... n$，当发现合法子串$str[l, r]$时，下一次应当跳转到位置$r+1$
4.  在遵循规则3的情况下，对于当前遍历的长度$i$，向左拓展的长度$lpart<i$，从而保证了左端不会重复统计

`3`中说的`合法子串`指的是向左拓展长度$lpart$+向右拓展长度$rpart \ge i$的后缀 （即连续的子串）

ac代码如下

```c++
//这里是头文件
struct suffix_array{
	// 这里是求后缀数组的代码
}SA[2];

struct RMQ{
    // 这里是求rmq的代码
}rmq[2];

ll solve(){
    ll k, len;
    cin >> k >> SA[0].s;
    len = strlen(SA[0].s);
    if(k == 1) return (len + 1) * len / 2; 
    for(int i=0; i<len; i++) SA[1].s[i] = SA[0].s[len-i-1]; // 反转字符串
    SA[1].s[len] = 0;
    SA[0].suffixArray(len, 128), SA[1].suffixArray(len, 128); // 128是字符集大小
    rmq[0].build(len, 0), rmq[1].build(len, 1);
    ll ans = 0;
    for(int i=1; i<len; i++){
        int s = 0;
        while(s + i < len){
            int lpart = rmq[1].query(len-s-1, len-(s+i)-1);
            int rpart = rmq[0].query(s, s+i);
            if(lpart + rpart < i) {s+=i; continue;} // 不能形成一个连续的子串，跳过
            int total_len = lpart + rpart + i - 1;
            if(total_len >= k * i){
                ans += total_len - k*i + 1;
            }
            s = s + i + rpart;
        }
    }
    return ans;
}
```





### POJ3693 子串循环节最大重复次数

见""题解们"



# 个人排位赛3



## BZOJ3894 最小割/建图

思路：关键在于建图

$S$集为文科，$T$集为理科，则从$s$向$student_i$建边($w=art[i]$)，从$student_i$向$t$建边($w=science[i]$)，

对于每个学生，新建两个个点$art_i,science_i$，建边

$s -> art_i (w=same\_art[i])$

$art_i -> neighbor_{ij}(w=INF)$

$neighbor_{ij} -> science_i(w=INF)$

$science_i->t(w=same_science[i])$

接着跑最小割即可



## Codeforces 1074B 树结构

题解： https://codeforces.com/blog/entry/62985 



## Codefocres 741D 树上启发式合并(dsu on tree)

维护每个节点到根节点的路径，若路径上某字符`x`的数量为奇数，则用$(1<<(x-' a '))$表示，否则该位为0

从根节点开始往子节点dfs，先遍历轻节点（遍历结束后清除轻节点的信息），再遍历重节点（重节点信息保留）。

对于子树上的一个节点（用二进制表示其到根节点`1`的路径），我们用数组$arr$保存一下最大的深度，那么更新答案时，只需要：

1.  计算重子节点到当前节点(称为$rt$)的最大可行路径长度
2.  暴力遍历所有轻子节点对应的子树($subtree_i$)
    1.  先计算经过$rt$的可行路径的最大长度
    2.  将$subtree_i$中的节点$p$的深度大于$arr$中的记录值，更新$arr$



## BZOJ 2118 同余最短路

同余最短路的简单题，注意$a_i=0$的情况



## Codeforces 587E 差分线性基

题意：给定$a_1,a_2,...a_n$，进行下列两种操作

1.  对$a_i\ i\in[l, r] \oplus x$
2.  求$a_i\ i\in[l, r]$通过异或操作能够表示出的数的数量

对于操作2，显然是求$a_l...a_r$中"异或不相关"(参考线性不相关的概念)的个数$x$，答案为$2^x$，可用线性基求解

根据[题解](https://codeforces.com/blog/entry/20971)，$a_l, a_{l+1}, ..., a_r$所能表出的数，都能由$a_l, a_l\oplus a_{l+1}, a_{l+1}\oplus a_{l+2}, ..., a_{r-1}\oplus a_r$表出。

令$b_i=a_{i-1}\oplus a_i$，考虑操作1$([l, r], x)$

该操作只会对$b_l,b_{r+1}$造成影响，只需将$b_l$修改为$b_l \oplus x$（$b_{r+1}$同理）即可！

因此我们用一棵线段树来维护$b_2...b_n$，再用一个别的什么（线段树/树状数组之类的）来维护$a_i$就好

[AC代码](/post/category/数据结构/线性基.html#二进制异或下的线性基)



## CodeChef Single Point of Failure 割点



# 个人排位赛4



## BZOJ 1857 三分法套三分法

标题即题解



## HDU 6191 可持久化字典树 *

很容易想到该问题可以转化为区间异或最大值问题

即对于区间$[l,r]$求一个数字$a_i$使得$x \oplus a_i$最大+

很显然使用字典树求解（没想到~）

可以分块，也可以可持久化来维护



## HDU 6212 区间DP

记录所有连续的球的数量$block[n]$

$dp[l][r]$表示消除块$[l,r]$所消耗的时间，转移方程如下(学过python的同学应该都看得懂)

1.  $dp[l][r]=min([dp[l][k] + dp[k+1][r]\quad for\ k\ in\ range(l, r)])$

如果块$l$与块$r$奇偶性相同（即颜色相同）（条件1），那么在1的基础上进行以下转移

2.  $dp[l][r] = min(dp[l][r], dp[l+1][r-1])$


如果满足条件1且$min(block[l], block[r])==1$，那么在上面的基础上进行以下转移

3.  $dp[l][r]=min([dp[l][r]] + [dp[l+1][k] + dp[k+1][r-1]\quad for\ k\ in\ range(l+r, r, 2)]\quad if\ block[k]==1)$

这里解释以下第三条转移方程

考虑左/右侧的块大小为1，那么我们可以从$(l,r)$寻找一个大小为1的块$k$并将其与左/右侧合**并且不被消去**，这时再消去$k$右/左侧的球并让$(l,k,r)$三个区间合并消去



## POJ 3074 舞蹈链 *

比赛过后看了眼别人的代码，我傻了~



## Gym 100134B *



# 个人排位赛5

我吐了，一题都没做出来



## HDU 4828 卡特兰数

卡特兰数模板题，见[这里](/post/OI-Wiki/数论/卡特兰数.html)



## HDU 6728 dp

目前网上找不到题解，此处留下[AC代码](https://gist.github.com/Chgtaxihe/06508eb2744e5223272346496001782d)

未补



## BZOJ 1041 暴力搜索(数学优化) 或 高斯整数分解

[参考题解](http://hzwer.com/1457.html)

可知圆的方程$x^2+y^2=r^2$

我们有$y^2=r^2-x^2=(r-x)(r+x)$

$y=\sqrt{(r-x)(r+x)}$

设$gcd[(r-x),(r+x)]=g$，$A=\frac{r-x}{g},B=\frac{r+x}{g}$，且$gcd(A, B)=1$，$A<\frac{r}{g}$

那么$y^2=g^2AB$，同时有$A+B=\frac{2r}{g}$，因此$g|2r$

设$a^2=A, b^2=B$

对于给定$g=G$，定有$G|2r$，且$\frac{2r}{G}=a^2+b^2$，$gcd(a^2,b^2)=gcd(a,b)=1$（必要性得证）

注意，若不判断$gcd(a, b)=1$，会导致重复统计

**充分性证明可以自己推导**

算法的python实现如下

```python
# 算法说明
ans = 0
# 值得一提的是，参考题解中lim_a = int(sqrt(g/2)) 不知是哪来的
def solve(lim_a, tmp): # tmp = 2*r/g 
    for a in range(1, lim_a+1):
        b = int(sqrt(tmp-a*a))
        if b <= a: break
        if b*b+a*a == tmp and gcd(a, b) == 1:
            ans += 1

limit = int(sqrt(r))
for i in range(1, r+1): # 枚举g
    if 2*r%i != 0: continue
    solve(*list(map(int, [sqrt(r/i), 2*r/i]))) # g = i
    if 2*r/i == i: break
    solve(*list(map(int, [sqrt(r/(2*r/i)), 2*r/(2*r/i)]))) # g = 2*r/i
    
print(ans * 4 + 4)
```

上述代码用C++实现，耗时84ms



然而本题有**更优**的方法，[参考博客](https://blog.csdn.net/megaowier/article/details/73312937)

本源勾股数组的解法见[我的笔记](/post/category/数论/高斯整数.html)，耗时8ms



### 相关

四平方和定理

.

## [CodeChef TREDEG](https://vjudge.net/contest/360739#problem/D) 生成树计数 prufer序列 公式推导 *



### 相关

[洛谷P4002](https://www.luogu.com.cn/problem/P4002)



## Codeforces 868F 决策单调性dp + 分治

容易想到$dp[i][j]=min(dp[i-1][k] + w(k+1,j)\ for\ k\ in\ range(i-1, j-1))$，$i$表示当前分为$i$段，$j$表示遍历到第$j$个数字，$w(k+1, j)$代表从位置$k+1$到位置$j$有多少对重复的数字。复杂度$O(n^2k)$

通过翻题解，可以得到以下结论：若为$k$使得$dp[i][j]=dp[i-1][k]+w(k+1, j)$最小的值，那么对于$z > j$，定有$dp[i-1][m] + w(m+1, z) > dp[i-1][k] + w(k+1, z)\ (0<m<k)$，即转移点具有单调性。

证明如下：

若对于$x<y<z$有

$dp[i-1][y] + w(y+1, z) < dp[i-1][x] + w(x+1, z)$且

$dp[i-1][x] + w(x+1, z+1) < dp[i-1][y] + w(y+1, z+1)$

合并两式，得$w(x+1, z+1) - w(x+1, z) < w(y+1, z+1) - w(y+1, z)$

由于区间$[x+1, z]$的长度大于$[y+1, z]$，因此，对于新增的一个数字$a_{z+1}$，其对前者的贡献应大于等于后者，与上式矛盾。

那么，对于一个点$mid$，若它的最优转移点为$p$，那么对于所有点$k<mid$，其最优转移点一定小于等于$k$，反之同理

详见[AC代码](#Codeforces 868F AC代码)



## 51Nod 1187 类欧几里得

[参考](https://www.cnblogs.com/ljh2000-jump/p/6675710.html)



核心代码

```c++
ll p, q;
void dfs(ll a, ll b, ll c, ll d){
    if(a == 0){
        p=1, q=d/c+1;
    }else if(a>=b){
        dfs(a%b, b, c-a/b*d, d);
        p += a/b*q;
    }else if(c > d){
        p = q = 1;
    }else{
        dfs(d, c, b, a);
        swap(q, p);
    }
}
```



类欧几里得太恐怖了



## 51Nod 1165 本原勾股数组/暴力搜索(数学优化)

见笔记[本原勾股数组](/post/category/数论/本原勾股数组.html)



## HDU 1693 插头dp *



# 个人排位赛6



## Codeforces 736B 哥德巴赫的猜想

```c++
ll n; cin >> n;
if(isprime(n)) print(1);
else if(isprime(n-2)) print(2);
else if((n&1)==0) print(2);
else print(3);
```



## POJ 2987 网络流-最大权闭合子图

见[我的笔记](/post/category/图论/2-SAT.html)



## Gym 101201F 2-SAT 

2-SAT 模板题

见[我的笔记](/post/category/图论/2-SAT.html)



## Gym 101201J 线段树找区间不大于C的数

搞了半天原来我是混过去的，复杂度不对（其实改一个值就对了，能过主要是数据没卡这个点？？）

对于当前数字$v$，用一个数$0\le x \le v$，那么$v$至少减少一半，因而对于一次查询，复杂度为$O(log_2v)$



## HDU 1043 八数码问题 康托展开 hash压缩



# 个人排位赛7

又被吊打了

![8QXjKA.png](https://s1.ax1x.com/2020/03/14/8QXjKA.png)

## BZOJ 1880/洛谷P2149 SPFA+拓扑排序

从四个点分别跑一次最短路，接着遍历点$1$到$n$

若$dist_{x1}[i]+dist_{y1}[i]=dist_{x1}[y1]$且$dist_{x2}[i]+dist_{y2}[i]=dist_{x2}[y2]$

则说明该点为两人最短路的可行公共点

那么对于这一点引出的所有边$(v, w)$

若$v$也属于可行公共点且$dist_{x1}[u]+w=dist_{x1}[v]$，那么将该边加入新图

对新图用拓扑排序跑一边最长路即可

(这种题的代码巨长，容易出错)



## POJ 2778 AC自动机+矩阵快速幂

对模式串建AC自动机，在trie树上建图，点分为"危险点"和"正常点"，且"危险点"与"正常点"之间没有路

这题真的是毒瘤，时限1s，疯狂TLE。

感谢`shengrang`这位老哥的题解：

>   矩阵快速幂的时候, 不要每次加上的时候都模除. 用longlong存矩阵, 然后加完一行模除一次..
>
>   直接TLE -> 150ms

或者，在写矩阵乘法的时候要用引用传递，则TLE -> 550ms

AC代码见[我的笔记](/post/category/字符串/AC自动机.html)



## BZOJ 2243 树链剖分/LCT

一眼树剖，问题在于怎么在有限的时间里不出错地把代码敲出来

就当复习了一遍树剖吧



## BZOJ 4004/洛谷P3265 实数线性基/高斯消元

题意：对于向量$\alpha_1, \alpha_2...\alpha_n$，每个向量有其对应的价格$c_i$，求极大线性无关组的最小价格

我们可以贪心的从小到大向线性基中插入向量，若该向量可以被表示，那么他就不必被选。

见笔记[线性基](/post/category/数据结构/线性基.html)

向线性基插入元素的这个过程其实就是高斯消元，只不过是从两种不同的角度看问题而已。



## Codeforces 1153E 避免假优化

[题解](https://codeforces.com/blog/entry/66539)

显然若答案为**奇数**，那么一定有一个端点在查询区间内，若为偶数，那么可能有也可能没有端点。

一开始我想的是将一个平面分为4个部分，然后递归询问的，但是细节比较难处理，WA了N次，另外这种方法的最坏复杂度可以达到$O(nlog\ n)$，显然不行。

一看题解发现是对行/列进行询问，找到对应行后二分（注意，不需要对最后一行/列进行询问）~



## HDU 2196 树直径/树上DP

这道题我是用树上dp做的，但其实有更简单的方法。

### 定理

树上任意一点对应的距离最远的端点一定是树的直径的两端点之一

即设树上直径为$(u, v)$（意为$u$到$v$的路径），那么对于任意一点$p$，树上与$p$距离最远的点要么是$u$，要么是$v$



# 个人排位赛8

<img src="https://s1.ax1x.com/2020/03/16/8tPfAK.jpg" width="200" alt="哭泣猫猫头"/>

##  POJ 1845 二分求等比数列和/模运算

这道题我使用二分做的，但其实还可以用适当的模运算公式求解

对于等比数列$1, a, a^2, a^3, ..., a^n$，可以用$\frac{a^{n+1}-1}{a-1}$求和。对于模$p$意义下的等比数列求和，可以利用以下公式

$a/b\%c=a\%(b*c)/b$ 见[笔记](/post/category/数论/模运算.html)

即如下代码

```c++
ll get_sum(ll p, ll t){ // qpow(p, t, d) 以为p的t次方对d取余
    ll div = (p-1) * mod;
    ll ans = (qpow(p, t+1, div) - 1 + div) % div;
    ans = ans / (p-1);
    return ans % mod;
}
```

若使用该方法，需要用`龟速乘`防止爆long long

另外，本题需要特判$b=0$的情况。



##  [CodeChef SUBLCM](https://vjudge.net/problem/CodeChef-SUBLCM) 代码技巧

题名： Subarray LCM

明显我们需要求出没有公因子的最长连续子序列的长度

代码技巧，具体解析已经写在注释中，直接贴[代码](#CodeChef SUBLCM AC代码)



##  [CodeChef ANUGCD](https://vjudge.net/problem/CodeChef-ANUGCD) 线段树/分块/树状数组 求区间最值

题名:  Maximum number, GCD condition

[题解1(线段树)](https://discussed.codechef.com/questions/39947/anugcd-editorial) [题解2(分块)](https://www.codechef.com/viewsolution/3620495) [题解3(树状数组)](https://www.codechef.com/viewsolution/3533495)

对每一个质数$p$，若存在$a[i] \% p = 0$，我们新建一个查询$RMQ$的工具，并将$\{a[i]\ \ \ if\ \ a[i]\%p=0\}$插入

由于一个数字$x$最多由$log\ x$个质因数组成，因此下列解法的空间复杂度均为$O(nlog\ n)$

用线段树的话需要动态开，并且维护$pos[i]$（代表质数$i$所含的每一个数字的位置）

用分块的话，可以按照题解2中所示，可以对所有素数$p$都建一段$rmq$，然后把所有段按$p$从小到大合并。

例如$a=\{2, 3, 4, 6\}$，那么质数$2$的$RMQ$为$p_2=\{2, 4, 6\}$，质数$3$的为$p_3=\{3, 6\}$，合并后为$\{2, 4, 6, 3, 6\}$，注意合并时要保存每一段的开头位置和长度。接着按分块的思想去做就好。

用树状数组是最简洁明了的。对每一个质数$p$开一个树状数组（善用vector），并维护$pos[i]$和$cnt[i]$即可。

三种方法时间复杂度都为$O(nlog\ n)$

AC代码见[我的题解](/solution.html)



##  [CodeChef AHWORK](https://vjudge.net/problem/CodeChef-AHWORK) DP

题名： Akhil And Pending Homework

[题解](https://discuss.codechef.com/t/ahwork-editorial/12578)

 $dp[i][j][a][b]$表示从字符串$i$到字符串$j$，且$s_i$的**从前往后**第$a$个字符与$s_j$**从后往前**第$b$个字符**之间**的字符已经计算过了，组成回文串所要删去的最小字符串数

接下来判断$s[i][a]==s[j][strlen(s[j]) - b - 1]$

如果上述条件成立，那么$dp[i][j][a][b]$的计算范围缩小2个字符，即如下所示

```c++
int & ans = dp[i][j][a][b];
li = strlen(s[i]), lj = strlen(s[j]);

if(s[i][a] == s[j][lj-b-1]){
    if(a + 1 < li && b+1 < lj) ans = min(ans, dp[i][j][a+1][b+1]);
    else if(a + 1 < li) ans = min(ans, dp[i][j-1][a+1][0]);
    else if(b + 1 < lj) ans = min(ans, dp[i+1][j][0][b+1]);
    else ans = min(ans, dp[i+1][j-1][0][0]);
}
```

显然当$a=0$时，我们可以尝试直接抛弃掉串$i$，即$ans=min(ans, dp[i+1][j][0][b])$  ① 

当$b=0$时同理，有$ans = min(ans, dp[i][j-1][a][0])$ ② 

当 $i>j$ 或 $i=j$ 时，到达递归的边界。

对于$i>j$分两种情况:

1.  由两个指针$a,b$各自遍历到了其所在串的末尾/头部的情况转移过来（即由$i<j$转移过来），这时候返回$0$即可
2.  由$i=j$转移过来，这种情况不存在，因为$i=j$已经是递归边界

对于$i=j$，另$b=len[i]-b-1$，若$s[i][a]=s[i][b]$，返回$0$，否则返回$1$

详见[AC代码](#CodeChef CALLSCHE AC代码)



##  [CodeChef CALLSCHE](https://vjudge.net/problem/CodeChef-CALLSCHE) 网络流 *

题名： Call Center Schedule



## Codeforces 718C 线段树维护矩阵

当时没做出来，后来一看代码发现是线段树写歪了，巨歪！



## Codeforces 954I FFT *



### 前置 Codeforces 939D 

并查集可解



## Codeforces 850C Dp SG函数 *

*看来我之前学了个假的SG函数，心累*

每个质数都是独立的，可视作不同的子游戏。

对于$mask$，$mask_i=1$意为存在一个数字$val$使得$val \% p^i=0$且$val\%p^{i+1}\ne0$

那么对于一个选定的$k$，则会将状态$mask$转化为$(mask\gg k)|(mask\&((1 \ll k) - 1))$

接着用`unordered_map`来保存状态就好



## HDU 4964 恶心模拟题 *



# 个人排位赛9

<img src="https://s1.ax1x.com/2020/03/21/8fOnxA.png" width=200>

## Codeforces 543B 多源最短路的复杂度

这题虽然AC了，但是仍然有必要记录一下学到的东西。

因为之前的个人赛里也有一道关于"公共路径"的题，很自然的想到做4次Dij，进而想到可以枚举公共路径的两个端点。接着距离就等于$dist[s1][i]+dist[j][t1]+dist[s2][i]+dist[j][t1]+dist[i][j]$

从$s、t$的最短路容易求，那么就剩下求$dist[i][j]$了。

到这里思路就卡住了，因为求任意两点间最常用的$Flody$算法复杂度是$O(n^3)$，在$n=3000$的情况下显然会TLE

卡了好久。

后来想到，我们只需要对每一个点做一次$BFS$就好，这样子复杂度为$O(n^2)$，完全可以接受！！

另外，$Dijkstra$单源最短路算法的复杂度为$O(n^2)$，二叉堆优化之后复杂度为$O(VlogV+E)$，求多源最短路的复杂度大约是$O(V(VlogV+E))$，要$Flody$何用？？

经过一番搜索，发现$Flody$似乎只适合于负权图。

因此，对于求任意两点之间的对短路：

1.  图中的所有边权相等：直接$BFS$即可，时间复杂度$O(n^2)$

2.  否则，看$n$的大小

    1.  $n$很小，可以偷下懒用$Flody$
    2.  $n$比较大，这时要看下有没有负权边
        1.  没有负权边，上$Dijkstra$，稠密图复杂度接近$O(n^3)$，稀疏图复杂度$O(n^2logn+ne)$
        2.  有负权边，那么可能是~~出题人想我死~~，或者思路想歪了
            1.  尝试用$SPFA$
            2.  事实上，对于负权图我们可以用改进的$Dijkstra$，详见[我的笔记](/post/category/图论/多源最短路.html)

    

    

## Codeforces 553B 找规律

一个循环的长度不会超过2，并且靠左边的循环的数字一定小于右边的，因此对于长度为$n$的排列，有$dp[i]=dp[i-1]+dp[i-2]$种可能

-----

下面尝试对上述假设进行证明：

设当前序列的长度为$n$，当$n$所在的循环长度$len=1$时显然可行，问题转化为$n'=n-1$的规模更小的问题。

当$len=2$，只需交换$val[n]$与$val[n-1]$，问题转化为$n'=n-2$的规模更小的问题

当$len=3$，设其所在的循环节为$(n, a, b)\ (n > a\ and \ n>b)$。显然$n$指向的是$b$而非$a$，与循环节的定义相背。

当$len>3$时同理。

-----

问题转化为如何求第k大

我们假设位置$i=1$所在的循环长度为$1$，那么剩下的数字所组成的序列就应当是字典序第$1$到第$dp[n-i]$大的。若$k>dp[n-i]$，说明$i=1$所在的循环长度不可能为$1$，于是$k-=dp[n-i]$，并$swap(ans[i], ans[i+1])$，问题规模缩小

```c++
# include <header_files>
long long dp[60] = {0, 1, 2}, n, k;
int ans[60];
void main(){
    cin >> n >> k;
    for(int i=3; i<=n; i++) dp[i] = dp[i-1] + dp[i-2];
    for(int i=0; i<=n; i++) ans[i] = i;
    int pos = 1;
    while(pos < n){
        if(dp[n - pos] >= k){
            pos++;
        }else{
            k -= dp[n-pos];
            swap(ans[pos], ans[pos+1]);
            pos += 2;
        }
    }
    for(int i=1; i<=n; i++) cout << ans[i] << (i==n?'\n':' ');
}
```



## Codeforces 578D 组合数学

出题人的题解根本不能看。。

[题解](/post/solutions/Codeforces578D.html)



## Codeforces 553C 思维 二分图

才发现我比赛的时候读错题了，其实这道题挺简单的<img src="https://s1.ax1x.com/2020/03/21/8fOnxA.png" width=100>



## Codeforces 538H 线段树扫描线/二分图

[二分图解法](https://www.xht37.com/cf538h-summer-dichotomy-%E9%A2%98%E8%A7%A3/)

惊了！！不考虑$t、T$的情况下假设有解，那么$n_1=min(r_i),n_2=max(l_i)$一定是解



### 相关

[扫描线](https://www.cnblogs.com/headchen/p/9172491.html)



## Codeforces 573E *

[题解](https://share.dmca.gripe/UTZYVKDb0VQ3xbbE.pdf)



## Codeforces 547D 欧拉回路/贪心

### 贪心

把$x$坐标相同的点**两两配对**，在每一对点间连边，如果剩下一个点未配对，则忽略该点

把$y$坐标相同的点**两两配对**，，在每一对点间连边，未配对的点忽略

对得到的图进行二分染色，得到的结果输出即可

[AC代码](#Codeforces 547D 贪心AC代码)



### 欧拉回路（标算的做法）

[AC代码](#Codeforces 547D 欧拉回路AC代码)



### 相关

fleury算法



## Codeforces 559D 皮克定理 *



# 个人排位赛10



## UVA 11235 RMQ/莫队

这题我使用ST表过的，真没想到还能用莫队

关键在于如何做到$O(1)$转移。

假设$cnt[i]$表示当前区间中数字$i$出现的次数，$icnt[i]$表示当前区间中**出现次数**为$i$的**不同**数字的个数

当向区间中加入一个数字时，维护$icnt、cnt$和当前区间答案$ans$

当区间去掉一个数字$x$时，$icnt[cnt[x]]-1$且$icnt[cnt[x]-1]+1$，接着让$cnt[x]-1$。若此时$icnt[ans]=0$，那么$ans=ans-1$

另：这道题每个testcase都memset重置$cnt$和$icnt$不会TLE



## HDU 6118 最小费用流 *



## BZOJ 1040/洛谷P2607 基环树DP(代码技巧)

很明显我们得到的是一个森林，每颗"树"**有且只有**一个环。

因此对于每棵树，我们可以断开环上的一条边$e$，$e$的端点不能同时选。我们只要对这两个端点分别跑一次dp即可。

用前向星存无向图时，可以很容易的删除一条无向边 (若要删除边$i$，在dfs时不访问边$i/(i \oplus 1)$即可)

[AC记录](https://www.luogu.com.cn/record/32343461)



## HDU 3336 KMP/后缀数组

第一反应是后缀数组+RMQ+二分，结果TLE了

后来往AC自动机的方向去考虑，结果发现这道题KMP可解，顺利AC

比赛过后看了古大哥的代码才知道后缀数组也能过，但是得加一点特效 T_T



!! 后缀数组做法待补充 !!



## HDU 6381 *

没看题

一句话题解：RMQ直接维护六边形，颜色用long long来压，合并的时候相当于6个六边形的值或起来 



## HDU 4801 恶心模拟题 *

都是暴力搜索，我怎么就TLE了呢？？？



# 个人排位赛 11

<img src="https://s1.ax1x.com/2020/03/28/GAPit0.png" alt="GAPit0.png" title="GAPit0.png" width=200/>

## CodeChef SUMAGCD GCD特性

请叫我猜结论大师！

道理我也不懂，但我猜最优解中会有$\mid A\mid =1$或$\mid B\mid =1$

[很棒的题解](https://stackoverflow.com/questions/56503879/maximize-the-sum-of-gcds-greatest-common-divisors-of-a-bipartition)



## HDU 3998 网络流建图 *



## BZOJ 4552/洛谷 P2824 01线段树排序

假设序列中只由0或1组成，可以用线段树对其进行排序，复杂度$O(mlogn)$

要求第$q$位数字，我们可以二分一个$mid$，将原序列中大于等于$mid$的值设为1，小于$mid$的值设为0。由此便可直到$val[q]$相对于$mid$的大小。



## Codeforces 1207F *



## UVA 10559 *



## Codeforces 1015F *



## CodeChef CHSTR *



# 个人排位赛12



## BZOJ 2002 LCT/分块 *

分块和莫队是好兄弟，想到莫队就该想到分块....

我们可以把跳转分为几种情况

1.  跳转后$pos'\ge n$ ，$next[pos]=-1$标记
2.  跳转后$pos'$与跳转前$pos$不在同一个块内，$next[pos]=pos'$直接跳转！
3.  跳转后$pos'$与跳转前$pos$在同一个块内，我们让$next[pos]=next[pos']$

修改的时候，我们直接修改整个块，查询的时候跳$next$就好

单次修改复杂度$O(n^{\frac{1}{2}})$，单次查询复杂度$O(n^{\frac{1}{2}})$



**不会LCT**



## Codeforces 412E

其实完全不用预处理，每次遇到`@`都for一遍，复杂度也就$O(3n)$

太复杂的代码反而不好debug

注意细节：`@`后紧跟`.`的子串是不合法的！



## Codeforces 463C *

## Codeforces 429A *

## POJ 1417 *

## BZOJ 2125 *



# 个人排位赛13

<img src="https://s1.ax1x.com/2020/03/16/8tPfAK.jpg" alt="8tPfAK.jpg" title="8tPfAK.jpg" width=200/>

## LightOJ 1236

计算每个质数的贡献即可

**总结教训**：

1.  数组开太大，应报**RE**而非**MLE**（取决于OJ运行方式，有些可能报MLE）
2.  预处理出所有质数时，范围内有多少个质数，数组就开多大！



以后看到恶心的`Memory limit 32768 kB`，心里要有数

| 数据类型 | 大小 | 内存大小（大约） |
| -------- | ---- | ---------------- |
| int      | 1e7  | 39, 516kB        |
| int      | 5e6  | 20, 000kB        |
| int      | 1e6  | 4, 376kB         |
| bool     | 1e7  | 10, 236kB        |
| char     | 1e7  | 10, 240kB        |



## Codeforces 12D CDQ/巧用树状数组

### CDQ解法

由于题目要求是严格小于，需要对CDQ进行一些改造。

1.  对$a$从小到大排序
2.  在进行二分时，由于是严格小于，因而如果要产生贡献，必须有$\forall a_{left},a_{right} \ a_{left} < a_{right}$
3.  在合并的时候，要从后往前遍历，判断左半部分的人是否会suicide，如果会就给他打上标记



为了保证2，我们需要分类讨论一下

1.  如果$a[from]=a[to]$，这一部分不可能产生贡献，因而只需要将其按$b$排序即可
2.  否则，我们要寻找一个分界点$mid$，使得对于$\forall a_i,a_j(from\le i \le mid,mid \lt j \le to), a_i<a_j$，注意细节即可(哭了，细节比想法重要！！)

[AC代码](/post/category/其他/CDQ分治.html#例题 Codeforces 12D)



### 树状数组解法

显然我们可以通过对$a$排序降低一维，问题就转化为：如何用树状数组解决2维偏序

其实，我们可以用树状数组存最大值，即通过$query(b_i)$将得到所有符合$b_j>b_i$的最大$c$值

理论上，我们可以通过cdq辅以该做法解决四维偏序的问题（太毒瘤了吧）...

[AC代码](/post/category/数据结构/树状数组.html#树状数组处理二位偏序)



## Codeforces 55D 数位dp *

数位dp和插头dp--两大毒瘤dp



## BZOJ 3562 *

## BZOJ 2584 *

## SGU 120 *



# 个人排位赛14

终于打完了...

## POJ 2751 双机调度（贪心）

比赛时第一反应就是贪心，但是调了很久都没调出来。

贪心方式：对于$t_1\le t_2$的任务，我们按$t_1$单调递增方式排序；对于$t_1\gt t_2$的任务，按$t_2$单调递减的方式排序。做的时候先做前者，再做后者，然后$O(n)$模拟即可。

稍微想想就觉得这种贪心很合理

<img src="https://s1.ax1x.com/2020/04/07/G2mMGT.gif" alt="G2mMGT.gif" title="G2mMGT.gif" width=200/>



## Codeforces 600E 代码技巧

一眼看出dsu on tree。但是比较难调，用了将近一个小时才做出来（主要是小错误卡了我好久）。

这里涉及到一个清空计数数组的操作，直接for或者memset肯定超时，我用一个比较麻烦的方法（打标记）来解决。

赛后看了眼队友的代码，发现只要把计数时的`+1` 换成它的逆操作（`-1`）即可实现清空...

所以说没事看看别人的AC代码还是有好处的。



## BZOJ 1025 思维+完全背包 *

比赛的时候读错题了，还以为要求所有可能的排列的数量，于是猜想答案是$n!$，看了眼样例发现不对，就此卡住。。

问题简述：给定数字$N$，使得$x_1+x_2+...+x_n=N\ (0<x_1,x_2,...x_n\le N)$，其中$n$可为任意正整数，求$lcm(x_1,...x_n)$可能的取值的个数。

核心代码

```c++
dp[0] = 1;
for(int i=0; i<prime_cnt; i++){
    for(int j=n; j>=prime[i]; j--){
        for(int k=prime[i]; k<=j; k*=prime[i])
            dp[j] += dp[j-k];
    }
}
for(int i=0; i<=n; i++) sum += dp[i];
cout << sum << endl;
```



## Codeforces 585D MidInMiddle *

## BZOJ 1189 二分+网络流*

## HDU 5890 *

## POJ 1033 *



# 附录

## Codeforces 868F AC代码

```c++
#include <bits/stdc++.h>
#define ll long long
#define F(i, n) for(int i=0, _iter_max=(n); i<_iter_max; i++)
#define range(i, l, r) for(int i=(l), _iter_max=(r); i<_iter_max; i++)

using namespace std;

const int maxn = 1e5 + 1000;

int a[maxn], cnt[maxn]={0};
ll dp[2][maxn], ans = 0, cl=1, cr=0, n, k;

ll query(int l, int r){ // 莫队
    while(cr < r) ans += cnt[a[++cr]]++;
    while(cr > r) ans -= --cnt[a[cr--]];
    while(cl < l) ans -= --cnt[a[cl++]];
    while(cl > l) ans += cnt[a[--cl]]++;
    return ans;
}

void dfs(int l, int r, int dl, int dr, int k){ // 二分dp
    if(l > r) return;
    int mid = (l + r) >> 1, pos=dl;
    for(int i=dl; i<=dr && i<mid; i++){
        ll v = query(i + 1, mid);
        if(dp[k][mid] > dp[k^1][i] + v){
            dp[k][mid] = dp[k^1][i] + v;
            pos = i;
        }
    }
    dfs(l, mid-1, dl, pos, k);
    dfs(mid+1, r, pos, dr, k);
}

int main(){
    memset(dp, 0x3f, sizeof dp);
    cin >> n >> k;
    range(i, 1, n+1) cin >> a[i];
    dp[0][0] = 0;
    for(int i=1; i<=k; i++){
        memset(dp[i&1], 0x3f, sizeof dp[i&1]);
        dfs(1, n, 0, n, i&1);
    }
    cout << dp[k&1][n] << endl;
}
```



## CodeChef SUBLCM AC代码

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int read(); // 快速读

const int maxn = 1e6 + 100;
int factor[maxn], pos[maxn];

void solve(){ // pos[i]里存放上一个质因子i所在的位置
    memset(pos, -1, sizeof pos); // 不会TLE
    int n = read(), ans = 0, a, tmp=-1;
    for(int i=0; i<n; i++){
        a = read();
        while(a > 1){
            int p = factor[a];
            tmp = max(tmp, pos[p]); // tmp+1 为可行范围的最左端
            pos[p] = i;
            while(a % p == 0) a/=p;
        }
        ans = max(ans, i - tmp);
    }
    cout << (ans > 1?ans:-1) << '\n';
}

int prime[maxn], prime_cnt=0, not_prime[maxn]={0};
signed main(){
    for(int i=2; i<maxn; i++){ // factor[i]中存放i的最小因子,显然可用线性筛求factor数组
        if(!not_prime[i]) prime[prime_cnt++] = i, factor[i] = i;
        for(int j=0; j<prime_cnt && i * prime[j] < maxn; j++){
            not_prime[i * prime[j]] = true;
            factor[i * prime[j]] = prime[j];
            if(i % prime[j] == 0) break; // 要放在最后一行
        }
    }
    int t = read();
    while(t--) solve();
}
```



## CodeChef CALLSCHE AC代码

```c++
#include <bits/stdc++.h>

using namespace std;

const int inf = 0x3f3f3f3f;
const int maxn = 1e3 + 100;

char str[maxn][5];
int len[maxn], dp[maxn][maxn][3][3], n;

int search(int i, int j, int a, int b){
    if(i > j) {
        assert(a == 0 && b == 0);
        return 0;
    }
    int & ans = dp[i][j][a][b];
    if(ans != -1) return ans;
    if(i == j) {
        assert(a <= len[i]-b-1);
        return ans = (str[i][a]!=str[i][len[i]-b-1]);
    }
    ans = inf;
    if(b == 0) ans = min(ans, 1 + search(i, j-1, a, 0));
    if(a == 0) ans = min(ans, 1 + search(i+1, j, 0, b));
    if(str[i][a] == str[j][len[j]-b-1]){
        if(a + 1 < len[i] && b + 1 < len[j]) ans = min(ans, search(i, j, a+1, b+1));
        else if(a+1 < len[i]) ans = min(ans, search(i, j-1, a+1, 0));
        else if(b+1 < len[j]) ans = min(ans, search(i+1, j, 0, b+1));
        else ans = min(ans, search(i+1, j-1, 0, 0));
    }
    return ans;
}

void solve(){
    memset(dp, -1, sizeof dp);
    cin >> n;
    for(int i=0; i<n; i++) cin >> str[i], len[i] = strlen(str[i]);
    cout << search(0, n-1, 0, 0) << endl;
}

int main(){
    int t; cin >> t;
    while(t--) solve();
}
```



## Codeforces 547D 贪心AC代码

```c++
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e5 + 1000;
vector<int> G[maxn];
int color[maxn], last_seen_x[maxn], last_seen_y[maxn], n;

void dfs(int u){
	for(int v:G[u]){
		if(color[v]==0) color[v] = 3-color[u], dfs(v);
	}
}

signed main(){
	cin >> n;
	for(int i=1, x, y; i<=n; i++){
		cin >> x >> y;
		if(last_seen_x[x]==0){
			last_seen_x[x] = i;
		}else{
			G[i].push_back(last_seen_x[x]);
			G[last_seen_x[x]].push_back(i);
			last_seen_x[x] = 0;
		}
		if(last_seen_y[y]==0){
			last_seen_y[y] = i;
		}else{
			G[i].push_back(last_seen_y[y]);
			G[last_seen_y[y]].push_back(i);
			last_seen_y[y] = 0;
		}
	}
	for(int i=1; i<=n; i++){
		if(color[i] == 0) color[i] = 1, dfs(i);
	}
	for(int i=1; i<=n; i++) cout << (color[i]==1?'r':'b');
	cout << endl;
}
```



## Codeforces 547D 欧拉回路AC代码

```c++
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e5 + 1;
int head[2*maxn]={0}, nxt[4*maxn], dest[4*maxn], edge_cnt=1;
int degree[2*maxn]={0}, n, color[maxn*4]={0};

void add_edge(int u, int v){
	nxt[++edge_cnt] = head[u];
	dest[edge_cnt] = v;
	head[u] = edge_cnt;
	degree[u]++;
}

void dfs(int u){ // dfs统计欧拉回路方向
	for(int &i=head[u], e; i; i=nxt[i]){ // 小优化:这里的i是引用！
		if(color[e=(i>>1)]) continue;
		color[e] = e<=n?((i&1)+1):-1; //(i&1)判断是左到右还是右到左
		dfs(dest[i]);
	}
}

signed main(){
	n = read();
	for(int i=0, u, v; i<n; i++){
		u = read(), v = read();
		add_edge(u, v+maxn);
		add_edge(v+maxn, u);
	}
	for(int i=1; i<=2*maxn; i++){
		if(degree[i] & 1) add_edge(0, i), add_edge(i, 0);
	}
	for(int i=1; i<=2*maxn; i++) dfs(i);
	for(int i=1; i<=n; i++)	putchar(color[i]==1?'r':'b');
	putchar('\n');
}
```







