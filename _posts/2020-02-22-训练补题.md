---
layout: post
title: 训练补题
---

* auto-gen TOC:
{:toc}

## [UVA-1395](https://vjudge.net/problem/UVA-1395) 生成树

问题：给定一个无向图，求最大边权与最小边权差值最小的生成树

解：假定该生成树里权值最小的边为$m$，此时最优解中最大的边对应着以$m$为最小边的最小生成树$tree_{min}$的最大边（假设存在另一合法生成树$tree_p$使得$max\_edge(tree_p) < max\_edge(tree_{min})$，由`Kruskal`算法的证明可知，$tree_p$中有环，且存在多于1个联通分量，故不合法）

#### Kruskal证明

假设存在某一步，算法选择了边$E_1$但是应选择$E_2$才能得到最小生成树$tree_{min}$，那么我们在$tree_{min}$中加入边$E_1$，此时该图中存在一个环，且环中存在长度大于$E_1$的边，此时将该边替换为$E_1$则可得到更优的生成树。



## [HYSBZ-2257](https://vjudge.net/problem/HYSBZ-2257) [裴蜀定理](https://blog.csdn.net/lleozhang/article/details/82935400)

该类倒水问题可以简化为$ax + by + cz + ... = C$

问题：给定$n$个瓶子，从中选出$k$个，使得用这$k$个瓶子倒出的水的最小值最大

答：由裴蜀定理知$ax + by + cz + ...=C$有解当且仅当$gcd(a, b, c, ...)|C$

问题转化为从$n$个数中选出$k$个使得$gcd(v_1, v_2, ..., v_k)$最大

那么我们求出所有数字的所有因子，并从大往小遍历，若因子个数多于$k$，即为答案



## [Codeforces 757C](https://vjudge.net/problem/CodeForces-757C) 算法实现

题目不难，问题在于如何分组

由于$\sum{g_i}<5*10^5$，因此，我们可以使用`vector<int> p[maxm]`，对于在`i`馆的宝可梦`j`，我们向`p[j]`中`push_back`一下`i`

那么如果`i`可以转化为`j`，既有`p[i] == p[j]`（直接比较`vector`）

`sort`一下再比较就好



## [HDU6346](https://vjudge.net/problem/HDU-6346) [KM算法(二分图最佳完美匹配)](https://www.cnblogs.com/zpfbuaa/p/7218607.html) [链接2](https://www.cnblogs.com/wenruo/p/5264235.html) [链接3](https://blog.sengxian.com/algorithms/km)

题意：求权值和最小的完全匹配

把cost取一下反即可

注意，这题不能使用dfs版本的km！！

### 关联

[匈牙利算法](https://www.renfei.org/blog/bipartite-matching.html)

[Ford-Fulkerson](https://zh.wikipedia.org/wiki/Ford%E2%80%93Fulkerson%E7%AE%97%E6%B3%95)



## [BZOJ1006](https://vjudge.net/problem/HYSBZ-1006) [弦图](https://www.cnblogs.com/lcf-2000/p/6259846.html) [链接2](https://oi-wiki.org/graph/chord/)

题意：给定一张弦图，要求相邻的点颜色不同，请你根据[ppt](http://files.cnblogs.com/files/lcf-2000/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE-cdq.pdf)第69页求出最小染色数

题解：根据ppt，弦图的最小染色数=最大团的点数

问题转变成了求最大团的点个数

注意：

1.  PPT中的"诱导子图"即"导出子图"(induced subgraph)
2.  图的极大团/最大团为NP-C问题，弦图的极大团可以在多项式复杂度的时间内完成
3.  ？？？



## [BZOJ1499](https://vjudge.net/problem/HYSBZ-1499) 三维DP

题意：累了，自己看吧

题解：

设$dp[i][x][y]$为第$i$个时间段后，以$(x,y)$为结束位置时，走过的最长路程

假设第$i$个时间段向右倾斜，那么

$dp[i][x][y] = max(dp[i-1][x][s] + y - s)$ for s in range(max(y-时间长度, left_most_block), y+1)

那么，对于固定的$i, x$，可以用单调队列来维护$dp[i-1][x][s]$（边dp边计算上一时间段的单调队列信息）

代码较长，需要小心低级错误



小技巧: memset(v, 128, sizeof v) 用来填充`-inf`