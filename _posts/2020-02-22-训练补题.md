---
layout: post
title: 训练补题
---

* auto-gen TOC:
{:toc}
# 个人排位赛1

## [UVA-1395](https://vjudge.net/problem/UVA-1395) 生成树

问题：给定一个无向图，求最大边权与最小边权差值最小的生成树

解：假定该生成树里权值最小的边为$m$，此时最优解中最大的边对应着以$m$为最小边的最小生成树$tree_{min}$的最大边（假设存在另一合法生成树$tree_p$使得$max\_edge(tree_p) < max\_edge(tree_{min})$，由`Kruskal`算法的证明可知，$tree_p$中有环，且存在多于1个联通分量，故不合法）

#### Kruskal证明

假设存在某一步，算法选择了边$E_1$但是应选择$E_2$才能得到最小生成树$tree_{min}$，那么我们在$tree_{min}$中加入边$E_1$，此时该图中存在一个环，且环中存在长度大于$E_1$的边，此时将该边替换为$E_1$则可得到更优的生成树。



## [HYSBZ-2257](https://vjudge.net/problem/HYSBZ-2257) [裴蜀定理](https://blog.csdn.net/lleozhang/article/details/82935400)

该类倒水问题可以简化为$ax + by + cz + ... = C$

问题：给定$n$个瓶子，从中选出$k$个，使得用这$k$个瓶子倒出的水的最小值最大

答：由裴蜀定理知$ax + by + cz + ...=C$有解当且仅当$gcd(a, b, c, ...)|C$

问题转化为从$n$个数中选出$k$个使得$gcd(v_1, v_2, ..., v_k)$最大

那么我们求出所有数字的所有因子，并从大往小遍历，若因子个数多于$k$，即为答案



## [Codeforces 757C](https://vjudge.net/problem/CodeForces-757C) 算法实现

题目不难，问题在于如何分组

由于$\sum{g_i}<5*10^5$，因此，我们可以使用`vector<int> p[maxm]`，对于在`i`馆的宝可梦`j`，我们向`p[j]`中`push_back`一下`i`

那么如果`i`可以转化为`j`，既有`p[i] == p[j]`（直接比较`vector`）

`sort`一下再比较就好



## [HDU6346](https://vjudge.net/problem/HDU-6346) [KM算法(二分图最佳完美匹配)](https://www.cnblogs.com/zpfbuaa/p/7218607.html) [链接2](https://www.cnblogs.com/wenruo/p/5264235.html) [链接3](https://blog.sengxian.com/algorithms/km)

题意：求权值和最小的完全匹配

把cost取一下反即可

注意，这题不能使用dfs版本的km！！

### 关联

[匈牙利算法](https://www.renfei.org/blog/bipartite-matching.html)

[Ford-Fulkerson](https://zh.wikipedia.org/wiki/Ford%E2%80%93Fulkerson%E7%AE%97%E6%B3%95)



## [BZOJ1006](https://vjudge.net/problem/HYSBZ-1006) [弦图](https://www.cnblogs.com/lcf-2000/p/6259846.html) [链接2](https://oi-wiki.org/graph/chord/)

题意：给定一张弦图，要求相邻的点颜色不同，请你根据[ppt](http://files.cnblogs.com/files/lcf-2000/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE-cdq.pdf)第69页求出最小染色数

题解：根据ppt，弦图的最小染色数=最大团的点数

问题转变成了求最大团的点个数

注意：

1.  PPT中的"诱导子图"即"导出子图"(induced subgraph)
2.  图的极大团/最大团为NP-C问题，弦图的极大团可以在多项式复杂度的时间内完成
3.  ？？？



## [BZOJ1499](https://vjudge.net/problem/HYSBZ-1499) 三维DP

题意：累了，自己看吧

题解：

设$dp[i][x][y]$为第$i$个时间段后，以$(x,y)$为结束位置时，走过的最长路程

假设第$i$个时间段向右倾斜，那么

$dp[i][x][y] = max(dp[i-1][x][s] + y - s)$ for s in range(max(y-时间长度, left_most_block), y+1)

那么，对于固定的$i, x$，可以用单调队列来维护$dp[i-1][x][s]$（边dp边计算上一时间段的单调队列信息）

代码较长，需要小心低级错误



小技巧: memset(v, 128, sizeof v) 可用来填充`-inf`



# 个人排位赛2



## [BZOJ5028](https://vjudge.net/problem/HYSBZ-5028) 线段树上GCD

题解： $gcd(a, b, c, ...)=gcd(a, b-a, c-b, ...)$

因此可以用线段树维护差分数组、区间gcd

当对$(l, r)$加上$x$，相当于$v_l+=x,v_{r+1}-=x$

对$(l, r)$统计答案，即求$gcd(\sum_i^l{v_i}, gcd(v_{l+1}, ..., v_r))$

注意：注意在线段树中特判$ql>qr$的情况（当查询$l=r$时可能出现）



## [Gym101237A](https://vjudge.net/problem/Gym-101237A) 线段树/主席树

题解：

### 巧用线段树

用线段树维护出现/未出现的值，线段树上每一个点代表其出现的时间，未出现的赋值为-inf，维护时间的最小值。

考虑对查询的区间进行排序，使得区间的右端点依次增大。从1到n依次遍历数组$A$，并向线段树中插入该数字。对于区间查询$(l, r)$，只需寻找线段树上出现时间小于$l$的位置即可。

### 主席树

事实上，主席树的做法同线段树差不多，只是不需要对查询区间排序而已（支持在线查询！！）。



## [计蒜客41413](https://vjudge.net/problem/计蒜客-41413) 生成函数

对不起，不会



### 关联

[整数划分](https://blog.csdn.net/u011889952/article/details/44813593)

广义牛顿二项式

泰勒展开



## [HDU6661] 后缀数组

题解:

先去做POJ3693，然后注意以下几点

1. HDU给了6秒的时限。向左/右拓展请大胆的用两个SA(减少分类讨论的难度)
2. 对k为1的情况进行特判(要保证循环节出现)

2.  求向左拓展的长度时别忘了字符串时翻转过来的，对应的位置应该从$pos$变为$len-pos-1$
3.  为了避免右端重复统计，遍历$1 ... n$，当发现合法子串$str[l, r]$时，下一次应当跳转到位置$r+1$
4.  在遵循规则3的情况下，对于当前遍历的长度$i$，向左拓展的长度$lpart<i$，从而保证了左端不会重复统计

`3`中说的`合法子串`指的是向左拓展长度$lpart$+向右拓展长度$rpart \ge i$的后缀 （即连续的子串）

ac代码如下

```c++
//这里是头文件
struct suffix_array{
	// 这里是求后缀数组的代码
}SA[2];

struct RMQ{
    // 这里是求rmq的代码
}rmq[2];

ll solve(){
    ll k, len;
    cin >> k >> SA[0].s;
    len = strlen(SA[0].s);
    if(k == 1) return (len + 1) * len / 2; 
    for(int i=0; i<len; i++) SA[1].s[i] = SA[0].s[len-i-1]; // 反转字符串
    SA[1].s[len] = 0;
    SA[0].suffixArray(len, 128), SA[1].suffixArray(len, 128); // 128是字符集大小
    rmq[0].build(len, 0), rmq[1].build(len, 1);
    ll ans = 0;
    for(int i=1; i<len; i++){
        int s = 0;
        while(s + i < len){
            int lpart = rmq[1].query(len-s-1, len-(s+i)-1);
            int rpart = rmq[0].query(s, s+i);
            if(lpart + rpart < i) {s+=i; continue;} // 不能形成一个连续的子串，跳过
            int total_len = lpart + rpart + i - 1;
            if(total_len >= k * i){
                ans += total_len - k*i + 1;
            }
            s = s + i + rpart;
        }
    }
    return ans;
}
```





### [POJ3693] 子串循环节最大重复次数

见""题解们"



# 个人排位赛3



## [BZOJ3894] 最小割/建图

思路：关键在于建图

$S$集为文科，$T$集为理科，则从$s$向$student_i$建边($w=art[i]$)，从$student_i$向$t$建边($w=science[i]$)，

对于每个学生，新建两个个点$art_i,science_i$，建边

$s -> art_i (w=same\_art[i])$

$art_i -> neighbor_{ij}(w=INF)$

$neighbor_{ij} -> science_i(w=INF)$

$science_i->t(w=same_science[i])$

接着跑最小割即可



## [Codeforces 1074B] 树结构

题解： https://codeforces.com/blog/entry/62985 



## [Codefocres 741D] 树上启发式合并(dsu on tree)

维护每个节点到根节点的路径，若路径上某字符`x`的数量为奇数，则用$(1<<(x-' a '))$表示，否则该位为0

从根节点开始往子节点dfs，先遍历轻节点（遍历结束后清除轻节点的信息），再遍历重节点（重节点信息保留）。

对于子树上的一个节点（用二进制表示其到根节点`1`的路径），我们用数组$arr$保存一下最大的深度，那么更新答案时，只需要：

1.  计算重子节点到当前节点(称为$rt$)的最大可行路径长度
2.  暴力遍历所有轻子节点对应的子树($subtree_i$)
    1.  先计算经过$rt$的可行路径的最大长度
    2.  将$subtree_i$中的节点$p$的深度大于$arr$中的记录值，更新$arr$



## [BZOJ 2118] 同余最短路

同余最短路的简单题，注意$a_i=0$的情况



## [Codeforces 587E] 差分线性 基



## [CodeChef Single Point of Failure] 割点



# 个人排位赛4



## [BZOJ 1857] 三分法套三分法

标题即题解



## [HDU 6191] 可持久化字典树

很容易想到该问题可以转化为区间异或最大值问题

即对于区间$[l,r]$求一个数字$a_i$使得$x \oplus a_i$最大+

很显然使用字典树求解（没想到~）

可以分块，也可以可持久化来维护



## [HDU 6212] 区间DP

记录所有连续的球的数量$block[n]$

$dp[l][r]$表示消除块$[l,r]$所消耗的时间，转移方程如下(学过python的同学应该都看得懂)

1.  $dp[l][r]=min([dp[l][k] + dp[k+1][r]\quad for\ k\ in\ range(l, r)])$

如果块$l$与块$r$奇偶性相同（即颜色相同）（条件1），那么在1的基础上进行以下转移

2.  $dp[l][r] = min(dp[l][r], dp[l+1][r-1])$


如果满足条件1且$min(block[l], block[r])==1$，那么在上面的基础上进行以下转移

3.  $dp[l][r]=min([dp[l][r]] + [dp[l+1][k] + dp[k+1][r-1]\quad for\ k\ in\ range(l+r, r, 2)]\quad if\ block[k]==1)$

这里解释以下第三条转移方程

考虑左/右侧的块大小为1，那么我们可以从$(l,r)$寻找一个大小为1的块$k$并将其与左/右侧合**并且不被消去**，这时再消去$k$右/左侧的球并让$(l,k,r)$三个区间合并消去



## [POJ 3074] 舞蹈链

比赛过后看了眼别人的代码，我傻了~



## [Gym 100134B]



# 个人排位赛5

我吐了，一题都没做出来



## [HDU 4828] 卡特兰数

卡特兰数模板题，见[这里](/post/OI-Wiki/数论/卡特兰数.html)



## [HDU 6728] dp

目前网上找不到题解，此处留下[AC代码](https://gist.github.com/Chgtaxihe/06508eb2744e5223272346496001782d)

未补



## [BZOJ 1041] 暴力搜索(数学优化) 或 本源勾股数组

[参考题解](http://hzwer.com/1457.html)

可知圆的方程$x^2+y^2=r^2$

我们有$y^2=r^2-x^2=(r-x)(r+x)$

$y=\sqrt{(r-x)(r+x)}$

设$gcd[(r-x),(r+x)]=g$，$A=\frac{r-x}{g},B=\frac{r+x}{g}$，且$gcd(A, B)=1$，$A<\frac{r}{g}$

那么$y^2=g^2AB$，同时有$A+B=\frac{2r}{g}$，因此$g|2r$

设$a^2=A, b^2=B$

对于给定$g=G$，定有$G|2r$，且$\frac{2r}{G}=a^2+b^2$，$gcd(a^2,b^2)=gcd(a,b)=1$（必要性得证）

注意，若不判断$gcd(a, b)=1$，会导致重复统计

**充分性证明可以自己推导**

算法的python实现如下

```python
# 算法说明
ans = 0
# 值得一提的是，参考题解中lim_a = int(sqrt(g/2)) 不知是哪来的
def solve(lim_a, tmp): # tmp = 2*r/g 
    for a in range(1, lim_a+1):
        b = int(sqrt(tmp-a*a))
        if b <= a: break
        if b*b+a*a == tmp and gcd(a, b) == 1:
            ans += 1

limit = int(sqrt(r))
for i in range(1, r+1): # 枚举g
    if 2*r%i != 0: continue
    solve(*list(map(int, [sqrt(r/i), 2*r/i]))) # g = i
    if 2*r/i == i: break
    solve(*list(map(int, [sqrt(r/(2*r/i)), 2*r/(2*r/i)]))) # g = 2*r/i
    
print(ans * 4 + 4)
```

上述代码用C++实现，耗时84ms



然而本题有**更优**的方法，[参考博客](https://blog.csdn.net/megaowier/article/details/73312937)

本源勾股数组的解法见[我的笔记](/post/category/数论/本源勾股数组.html)



### 相关

四平方和定理

.

## [CodeChef TREDEG](https://vjudge.net/contest/360739#problem/D) 生成树计数 prufer序列 公式推导



### 相关

[洛谷P4002](https://www.luogu.com.cn/problem/P4002)



## [Codeforces 868F](https://codeforces.com/problemset/problem/868/F) 决策单调性dp + 分治

容易想到$dp[i][j]=min(dp[i-1][k] + w(k+1,j)\ for\ k\ in\ range(i-1, j-1))$，$i$表示当前分为$i$段，$j$表示遍历到第$j$个数字，$w(k+1, j)$代表从位置$k+1$到位置$j$有多少对重复的数字。复杂度$O(n^2k)$

通过翻题解，可以得到以下结论：若为$k$使得$dp[i][j]=dp[i-1][k]+w(k+1, j)$最小的值，那么对于$z > j$，定有$dp[i-1][m] + w(m+1, z) > dp[i-1][k] + w(k+1, z)\ (0<m<k)$，即转移点具有单调性。

证明如下：

若对于$x<y<z$有

$dp[i-1][y] + w(y+1, z) < dp[i-1][x] + w(x+1, z)$且

$dp[i-1][x] + w(x+1, z+1) < dp[i-1][y] + w(y+1, z+1)$

合并两式，得$w(x+1, z+1) - w(x+1, z) < w(y+1, z+1) - w(y+1, z)$

由于区间$[x+1, z]$的长度大于$[y+1, z]$，因此，对于新增的一个数字$a_{z+1}$，其对前者的贡献应大于等于后者，与上式矛盾。

那么，对于一个点$mid$，若它的最优转移点为$p$，那么对于所有点$k<mid$，其最优转移点一定小于等于$k$，反之同理

详见[AC代码](#Codeforces 868F AC代码)



## [51Nod 1187] 类欧几里得



## [51Nod 1165] 数论



## [HDU 1693] 插头dp



# 个人排位赛6



## [Codeforces 736B] 哥德巴赫的猜想



```c++
ll n; cin >> n;
if(isprime(n)) print(1);
else if(isprime(n-2)) print(2);
else if((n&1)==0) print(2);
else print(3);
```



## [POJ 2987] 网络流-最大权闭合子图



## [Gym 101201F] 2-SAT



## [Gym 101201J] 线段树找区间不大于C的数

搞了半天原来我是混过去的，复杂度不对（其实改一个值就对了，能过主要是数据没卡这个点？？）

对于当前数字$v$，用一个数$0\le x \le v$，那么$v$至少减少一半，因而对于一次查询，复杂度为$O(log_2v)$



## [HDU 1043] 八数码问题 康托展开 hash压缩





# 附录

## Codeforces 868F AC代码

```c++
#include <bits/stdc++.h>
#define ll long long
#define F(i, n) for(int i=0, _iter_max=(n); i<_iter_max; i++)
#define range(i, l, r) for(int i=(l), _iter_max=(r); i<_iter_max; i++)

using namespace std;

const int maxn = 1e5 + 1000;

int a[maxn], cnt[maxn]={0};
ll dp[2][maxn], ans = 0, cl=1, cr=0;

ll query(int l, int r){
    while(cr < r) ans += cnt[a[++cr]]++;
    while(cr > r) ans -= --cnt[a[cr--]];
    while(cl < l) ans -= --cnt[a[cl++]];
    while(cl > l) ans += cnt[a[--cl]]++;
    return ans;
}

void dfs(int l, int r, int dl, int dr, int k){
    if(l > r) return;
    int mid = (l + r) >> 1, pos=dl;
    for(int i=dl; i<=dr && i<mid; i++){
        ll v = query(i + 1, mid);
        if(dp[k][mid] > dp[k^1][i] + v){
            dp[k][mid] = dp[k^1][i] + v;
            pos = i;
        }
    }
    dfs(l, mid-1, dl, pos, k);
    dfs(mid+1, r, pos, dr, k);
}

void solve(){
    memset(dp, 0x3f, sizeof dp);
    int n, k;
    cin >> n >> k;
    range(i, 1, n+1) cin >> a[i];
    dp[0][0] = 0;
    for(int i=1; i<=k; i++){
        memset(dp[i&1], 0x3f, sizeof dp[i&1]);
        dfs(1, n, 0, n, i&1);
    }
    cout << dp[k&1][n] << endl;
}

int main(){
    solve();
}
```















